/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 0.0.0
 * source: protos/ydb_monitoring.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./ydb_operation";
import * as pb_1 from "google-protobuf";
export namespace Ydb.Monitoring {
    export class StatusFlag extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): StatusFlag {
            const message = new StatusFlag({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StatusFlag {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StatusFlag();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StatusFlag {
            return StatusFlag.deserialize(bytes);
        }
    }
    export namespace StatusFlag {
        export enum Status {
            UNSPECIFIED = 0,
            GREY = 1,
            GREEN = 2,
            BLUE = 3,
            YELLOW = 4,
            ORANGE = 5,
            RED = 6
        }
    }
    export class SelfCheckRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            operation_params?: dependency_1.Ydb.Operations.OperationParams;
            return_verbose_status?: boolean;
            minimum_status?: StatusFlag.Status;
            maximum_level?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("operation_params" in data && data.operation_params != undefined) {
                    this.operation_params = data.operation_params;
                }
                if ("return_verbose_status" in data && data.return_verbose_status != undefined) {
                    this.return_verbose_status = data.return_verbose_status;
                }
                if ("minimum_status" in data && data.minimum_status != undefined) {
                    this.minimum_status = data.minimum_status;
                }
                if ("maximum_level" in data && data.maximum_level != undefined) {
                    this.maximum_level = data.maximum_level;
                }
            }
        }
        get operation_params() {
            return pb_1.Message.getWrapperField(this, dependency_1.Ydb.Operations.OperationParams, 1) as dependency_1.Ydb.Operations.OperationParams;
        }
        set operation_params(value: dependency_1.Ydb.Operations.OperationParams) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_operation_params() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get return_verbose_status() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set return_verbose_status(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        get minimum_status() {
            return pb_1.Message.getFieldWithDefault(this, 3, StatusFlag.Status.UNSPECIFIED) as StatusFlag.Status;
        }
        set minimum_status(value: StatusFlag.Status) {
            pb_1.Message.setField(this, 3, value);
        }
        get maximum_level() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set maximum_level(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            operation_params?: ReturnType<typeof dependency_1.Ydb.Operations.OperationParams.prototype.toObject>;
            return_verbose_status?: boolean;
            minimum_status?: StatusFlag.Status;
            maximum_level?: number;
        }): SelfCheckRequest {
            const message = new SelfCheckRequest({});
            if (data.operation_params != null) {
                message.operation_params = dependency_1.Ydb.Operations.OperationParams.fromObject(data.operation_params);
            }
            if (data.return_verbose_status != null) {
                message.return_verbose_status = data.return_verbose_status;
            }
            if (data.minimum_status != null) {
                message.minimum_status = data.minimum_status;
            }
            if (data.maximum_level != null) {
                message.maximum_level = data.maximum_level;
            }
            return message;
        }
        toObject() {
            const data: {
                operation_params?: ReturnType<typeof dependency_1.Ydb.Operations.OperationParams.prototype.toObject>;
                return_verbose_status?: boolean;
                minimum_status?: StatusFlag.Status;
                maximum_level?: number;
            } = {};
            if (this.operation_params != null) {
                data.operation_params = this.operation_params.toObject();
            }
            if (this.return_verbose_status != null) {
                data.return_verbose_status = this.return_verbose_status;
            }
            if (this.minimum_status != null) {
                data.minimum_status = this.minimum_status;
            }
            if (this.maximum_level != null) {
                data.maximum_level = this.maximum_level;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_operation_params)
                writer.writeMessage(1, this.operation_params, () => this.operation_params.serialize(writer));
            if (this.return_verbose_status != false)
                writer.writeBool(2, this.return_verbose_status);
            if (this.minimum_status != StatusFlag.Status.UNSPECIFIED)
                writer.writeEnum(3, this.minimum_status);
            if (this.maximum_level != 0)
                writer.writeUint32(4, this.maximum_level);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SelfCheckRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SelfCheckRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.operation_params, () => message.operation_params = dependency_1.Ydb.Operations.OperationParams.deserialize(reader));
                        break;
                    case 2:
                        message.return_verbose_status = reader.readBool();
                        break;
                    case 3:
                        message.minimum_status = reader.readEnum();
                        break;
                    case 4:
                        message.maximum_level = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SelfCheckRequest {
            return SelfCheckRequest.deserialize(bytes);
        }
    }
    export class SelfCheckResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            operation?: dependency_1.Ydb.Operations.Operation;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("operation" in data && data.operation != undefined) {
                    this.operation = data.operation;
                }
            }
        }
        get operation() {
            return pb_1.Message.getWrapperField(this, dependency_1.Ydb.Operations.Operation, 1) as dependency_1.Ydb.Operations.Operation;
        }
        set operation(value: dependency_1.Ydb.Operations.Operation) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_operation() {
            return pb_1.Message.getField(this, 1) != null;
        }
        static fromObject(data: {
            operation?: ReturnType<typeof dependency_1.Ydb.Operations.Operation.prototype.toObject>;
        }): SelfCheckResponse {
            const message = new SelfCheckResponse({});
            if (data.operation != null) {
                message.operation = dependency_1.Ydb.Operations.Operation.fromObject(data.operation);
            }
            return message;
        }
        toObject() {
            const data: {
                operation?: ReturnType<typeof dependency_1.Ydb.Operations.Operation.prototype.toObject>;
            } = {};
            if (this.operation != null) {
                data.operation = this.operation.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_operation)
                writer.writeMessage(1, this.operation, () => this.operation.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SelfCheckResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SelfCheckResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.operation, () => message.operation = dependency_1.Ydb.Operations.Operation.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SelfCheckResponse {
            return SelfCheckResponse.deserialize(bytes);
        }
    }
    export class NodeCheckRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            operation_params?: dependency_1.Ydb.Operations.OperationParams;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("operation_params" in data && data.operation_params != undefined) {
                    this.operation_params = data.operation_params;
                }
            }
        }
        get operation_params() {
            return pb_1.Message.getWrapperField(this, dependency_1.Ydb.Operations.OperationParams, 1) as dependency_1.Ydb.Operations.OperationParams;
        }
        set operation_params(value: dependency_1.Ydb.Operations.OperationParams) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_operation_params() {
            return pb_1.Message.getField(this, 1) != null;
        }
        static fromObject(data: {
            operation_params?: ReturnType<typeof dependency_1.Ydb.Operations.OperationParams.prototype.toObject>;
        }): NodeCheckRequest {
            const message = new NodeCheckRequest({});
            if (data.operation_params != null) {
                message.operation_params = dependency_1.Ydb.Operations.OperationParams.fromObject(data.operation_params);
            }
            return message;
        }
        toObject() {
            const data: {
                operation_params?: ReturnType<typeof dependency_1.Ydb.Operations.OperationParams.prototype.toObject>;
            } = {};
            if (this.operation_params != null) {
                data.operation_params = this.operation_params.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_operation_params)
                writer.writeMessage(1, this.operation_params, () => this.operation_params.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): NodeCheckRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new NodeCheckRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.operation_params, () => message.operation_params = dependency_1.Ydb.Operations.OperationParams.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): NodeCheckRequest {
            return NodeCheckRequest.deserialize(bytes);
        }
    }
    export class NodeCheckResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            operation?: dependency_1.Ydb.Operations.Operation;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("operation" in data && data.operation != undefined) {
                    this.operation = data.operation;
                }
            }
        }
        get operation() {
            return pb_1.Message.getWrapperField(this, dependency_1.Ydb.Operations.Operation, 1) as dependency_1.Ydb.Operations.Operation;
        }
        set operation(value: dependency_1.Ydb.Operations.Operation) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_operation() {
            return pb_1.Message.getField(this, 1) != null;
        }
        static fromObject(data: {
            operation?: ReturnType<typeof dependency_1.Ydb.Operations.Operation.prototype.toObject>;
        }): NodeCheckResponse {
            const message = new NodeCheckResponse({});
            if (data.operation != null) {
                message.operation = dependency_1.Ydb.Operations.Operation.fromObject(data.operation);
            }
            return message;
        }
        toObject() {
            const data: {
                operation?: ReturnType<typeof dependency_1.Ydb.Operations.Operation.prototype.toObject>;
            } = {};
            if (this.operation != null) {
                data.operation = this.operation.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_operation)
                writer.writeMessage(1, this.operation, () => this.operation.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): NodeCheckResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new NodeCheckResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.operation, () => message.operation = dependency_1.Ydb.Operations.Operation.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): NodeCheckResponse {
            return NodeCheckResponse.deserialize(bytes);
        }
    }
    export class SelfCheck extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): SelfCheck {
            const message = new SelfCheck({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SelfCheck {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SelfCheck();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SelfCheck {
            return SelfCheck.deserialize(bytes);
        }
    }
    export namespace SelfCheck {
        export enum Result {
            UNSPECIFIED = 0,
            GOOD = 1,
            DEGRADED = 2,
            MAINTENANCE_REQUIRED = 3,
            EMERGENCY = 4
        }
    }
    export class StoragePDiskStatus extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: string;
            overall?: StatusFlag.Status;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("overall" in data && data.overall != undefined) {
                    this.overall = data.overall;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get overall() {
            return pb_1.Message.getFieldWithDefault(this, 2, StatusFlag.Status.UNSPECIFIED) as StatusFlag.Status;
        }
        set overall(value: StatusFlag.Status) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            id?: string;
            overall?: StatusFlag.Status;
        }): StoragePDiskStatus {
            const message = new StoragePDiskStatus({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.overall != null) {
                message.overall = data.overall;
            }
            return message;
        }
        toObject() {
            const data: {
                id?: string;
                overall?: StatusFlag.Status;
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.overall != null) {
                data.overall = this.overall;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id.length)
                writer.writeString(1, this.id);
            if (this.overall != StatusFlag.Status.UNSPECIFIED)
                writer.writeEnum(2, this.overall);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StoragePDiskStatus {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StoragePDiskStatus();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readString();
                        break;
                    case 2:
                        message.overall = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StoragePDiskStatus {
            return StoragePDiskStatus.deserialize(bytes);
        }
    }
    export class StorageVDiskStatus extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: string;
            overall?: StatusFlag.Status;
            vdisk_status?: StatusFlag.Status;
            pdisk?: StoragePDiskStatus;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("overall" in data && data.overall != undefined) {
                    this.overall = data.overall;
                }
                if ("vdisk_status" in data && data.vdisk_status != undefined) {
                    this.vdisk_status = data.vdisk_status;
                }
                if ("pdisk" in data && data.pdisk != undefined) {
                    this.pdisk = data.pdisk;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get overall() {
            return pb_1.Message.getFieldWithDefault(this, 2, StatusFlag.Status.UNSPECIFIED) as StatusFlag.Status;
        }
        set overall(value: StatusFlag.Status) {
            pb_1.Message.setField(this, 2, value);
        }
        get vdisk_status() {
            return pb_1.Message.getFieldWithDefault(this, 3, StatusFlag.Status.UNSPECIFIED) as StatusFlag.Status;
        }
        set vdisk_status(value: StatusFlag.Status) {
            pb_1.Message.setField(this, 3, value);
        }
        get pdisk() {
            return pb_1.Message.getWrapperField(this, StoragePDiskStatus, 4) as StoragePDiskStatus;
        }
        set pdisk(value: StoragePDiskStatus) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_pdisk() {
            return pb_1.Message.getField(this, 4) != null;
        }
        static fromObject(data: {
            id?: string;
            overall?: StatusFlag.Status;
            vdisk_status?: StatusFlag.Status;
            pdisk?: ReturnType<typeof StoragePDiskStatus.prototype.toObject>;
        }): StorageVDiskStatus {
            const message = new StorageVDiskStatus({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.overall != null) {
                message.overall = data.overall;
            }
            if (data.vdisk_status != null) {
                message.vdisk_status = data.vdisk_status;
            }
            if (data.pdisk != null) {
                message.pdisk = StoragePDiskStatus.fromObject(data.pdisk);
            }
            return message;
        }
        toObject() {
            const data: {
                id?: string;
                overall?: StatusFlag.Status;
                vdisk_status?: StatusFlag.Status;
                pdisk?: ReturnType<typeof StoragePDiskStatus.prototype.toObject>;
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.overall != null) {
                data.overall = this.overall;
            }
            if (this.vdisk_status != null) {
                data.vdisk_status = this.vdisk_status;
            }
            if (this.pdisk != null) {
                data.pdisk = this.pdisk.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id.length)
                writer.writeString(1, this.id);
            if (this.overall != StatusFlag.Status.UNSPECIFIED)
                writer.writeEnum(2, this.overall);
            if (this.vdisk_status != StatusFlag.Status.UNSPECIFIED)
                writer.writeEnum(3, this.vdisk_status);
            if (this.has_pdisk)
                writer.writeMessage(4, this.pdisk, () => this.pdisk.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StorageVDiskStatus {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StorageVDiskStatus();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readString();
                        break;
                    case 2:
                        message.overall = reader.readEnum();
                        break;
                    case 3:
                        message.vdisk_status = reader.readEnum();
                        break;
                    case 4:
                        reader.readMessage(message.pdisk, () => message.pdisk = StoragePDiskStatus.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StorageVDiskStatus {
            return StorageVDiskStatus.deserialize(bytes);
        }
    }
    export class StorageGroupStatus extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: string;
            overall?: StatusFlag.Status;
            vdisks?: StorageVDiskStatus[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("overall" in data && data.overall != undefined) {
                    this.overall = data.overall;
                }
                if ("vdisks" in data && data.vdisks != undefined) {
                    this.vdisks = data.vdisks;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get overall() {
            return pb_1.Message.getFieldWithDefault(this, 2, StatusFlag.Status.UNSPECIFIED) as StatusFlag.Status;
        }
        set overall(value: StatusFlag.Status) {
            pb_1.Message.setField(this, 2, value);
        }
        get vdisks() {
            return pb_1.Message.getRepeatedWrapperField(this, StorageVDiskStatus, 3) as StorageVDiskStatus[];
        }
        set vdisks(value: StorageVDiskStatus[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        static fromObject(data: {
            id?: string;
            overall?: StatusFlag.Status;
            vdisks?: ReturnType<typeof StorageVDiskStatus.prototype.toObject>[];
        }): StorageGroupStatus {
            const message = new StorageGroupStatus({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.overall != null) {
                message.overall = data.overall;
            }
            if (data.vdisks != null) {
                message.vdisks = data.vdisks.map(item => StorageVDiskStatus.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                id?: string;
                overall?: StatusFlag.Status;
                vdisks?: ReturnType<typeof StorageVDiskStatus.prototype.toObject>[];
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.overall != null) {
                data.overall = this.overall;
            }
            if (this.vdisks != null) {
                data.vdisks = this.vdisks.map((item: StorageVDiskStatus) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id.length)
                writer.writeString(1, this.id);
            if (this.overall != StatusFlag.Status.UNSPECIFIED)
                writer.writeEnum(2, this.overall);
            if (this.vdisks.length)
                writer.writeRepeatedMessage(3, this.vdisks, (item: StorageVDiskStatus) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StorageGroupStatus {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StorageGroupStatus();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readString();
                        break;
                    case 2:
                        message.overall = reader.readEnum();
                        break;
                    case 3:
                        reader.readMessage(message.vdisks, () => pb_1.Message.addToRepeatedWrapperField(message, 3, StorageVDiskStatus.deserialize(reader), StorageVDiskStatus));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StorageGroupStatus {
            return StorageGroupStatus.deserialize(bytes);
        }
    }
    export class StoragePoolStatus extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: string;
            overall?: StatusFlag.Status;
            groups?: StorageGroupStatus[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("overall" in data && data.overall != undefined) {
                    this.overall = data.overall;
                }
                if ("groups" in data && data.groups != undefined) {
                    this.groups = data.groups;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get overall() {
            return pb_1.Message.getFieldWithDefault(this, 2, StatusFlag.Status.UNSPECIFIED) as StatusFlag.Status;
        }
        set overall(value: StatusFlag.Status) {
            pb_1.Message.setField(this, 2, value);
        }
        get groups() {
            return pb_1.Message.getRepeatedWrapperField(this, StorageGroupStatus, 3) as StorageGroupStatus[];
        }
        set groups(value: StorageGroupStatus[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        static fromObject(data: {
            id?: string;
            overall?: StatusFlag.Status;
            groups?: ReturnType<typeof StorageGroupStatus.prototype.toObject>[];
        }): StoragePoolStatus {
            const message = new StoragePoolStatus({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.overall != null) {
                message.overall = data.overall;
            }
            if (data.groups != null) {
                message.groups = data.groups.map(item => StorageGroupStatus.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                id?: string;
                overall?: StatusFlag.Status;
                groups?: ReturnType<typeof StorageGroupStatus.prototype.toObject>[];
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.overall != null) {
                data.overall = this.overall;
            }
            if (this.groups != null) {
                data.groups = this.groups.map((item: StorageGroupStatus) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id.length)
                writer.writeString(1, this.id);
            if (this.overall != StatusFlag.Status.UNSPECIFIED)
                writer.writeEnum(2, this.overall);
            if (this.groups.length)
                writer.writeRepeatedMessage(3, this.groups, (item: StorageGroupStatus) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StoragePoolStatus {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StoragePoolStatus();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readString();
                        break;
                    case 2:
                        message.overall = reader.readEnum();
                        break;
                    case 3:
                        reader.readMessage(message.groups, () => pb_1.Message.addToRepeatedWrapperField(message, 3, StorageGroupStatus.deserialize(reader), StorageGroupStatus));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StoragePoolStatus {
            return StoragePoolStatus.deserialize(bytes);
        }
    }
    export class StorageStatus extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            overall?: StatusFlag.Status;
            pools?: StoragePoolStatus[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("overall" in data && data.overall != undefined) {
                    this.overall = data.overall;
                }
                if ("pools" in data && data.pools != undefined) {
                    this.pools = data.pools;
                }
            }
        }
        get overall() {
            return pb_1.Message.getFieldWithDefault(this, 1, StatusFlag.Status.UNSPECIFIED) as StatusFlag.Status;
        }
        set overall(value: StatusFlag.Status) {
            pb_1.Message.setField(this, 1, value);
        }
        get pools() {
            return pb_1.Message.getRepeatedWrapperField(this, StoragePoolStatus, 2) as StoragePoolStatus[];
        }
        set pools(value: StoragePoolStatus[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            overall?: StatusFlag.Status;
            pools?: ReturnType<typeof StoragePoolStatus.prototype.toObject>[];
        }): StorageStatus {
            const message = new StorageStatus({});
            if (data.overall != null) {
                message.overall = data.overall;
            }
            if (data.pools != null) {
                message.pools = data.pools.map(item => StoragePoolStatus.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                overall?: StatusFlag.Status;
                pools?: ReturnType<typeof StoragePoolStatus.prototype.toObject>[];
            } = {};
            if (this.overall != null) {
                data.overall = this.overall;
            }
            if (this.pools != null) {
                data.pools = this.pools.map((item: StoragePoolStatus) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.overall != StatusFlag.Status.UNSPECIFIED)
                writer.writeEnum(1, this.overall);
            if (this.pools.length)
                writer.writeRepeatedMessage(2, this.pools, (item: StoragePoolStatus) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StorageStatus {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StorageStatus();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.overall = reader.readEnum();
                        break;
                    case 2:
                        reader.readMessage(message.pools, () => pb_1.Message.addToRepeatedWrapperField(message, 2, StoragePoolStatus.deserialize(reader), StoragePoolStatus));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): StorageStatus {
            return StorageStatus.deserialize(bytes);
        }
    }
    export class ComputeTabletStatus extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            overall?: StatusFlag.Status;
            type?: string;
            state?: string;
            count?: number;
            id?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("overall" in data && data.overall != undefined) {
                    this.overall = data.overall;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("state" in data && data.state != undefined) {
                    this.state = data.state;
                }
                if ("count" in data && data.count != undefined) {
                    this.count = data.count;
                }
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
            }
        }
        get overall() {
            return pb_1.Message.getFieldWithDefault(this, 1, StatusFlag.Status.UNSPECIFIED) as StatusFlag.Status;
        }
        set overall(value: StatusFlag.Status) {
            pb_1.Message.setField(this, 1, value);
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set type(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get state() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set state(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get count() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set count(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 5, []) as string[];
        }
        set id(value: string[]) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            overall?: StatusFlag.Status;
            type?: string;
            state?: string;
            count?: number;
            id?: string[];
        }): ComputeTabletStatus {
            const message = new ComputeTabletStatus({});
            if (data.overall != null) {
                message.overall = data.overall;
            }
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.state != null) {
                message.state = data.state;
            }
            if (data.count != null) {
                message.count = data.count;
            }
            if (data.id != null) {
                message.id = data.id;
            }
            return message;
        }
        toObject() {
            const data: {
                overall?: StatusFlag.Status;
                type?: string;
                state?: string;
                count?: number;
                id?: string[];
            } = {};
            if (this.overall != null) {
                data.overall = this.overall;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.state != null) {
                data.state = this.state;
            }
            if (this.count != null) {
                data.count = this.count;
            }
            if (this.id != null) {
                data.id = this.id;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.overall != StatusFlag.Status.UNSPECIFIED)
                writer.writeEnum(1, this.overall);
            if (this.type.length)
                writer.writeString(2, this.type);
            if (this.state.length)
                writer.writeString(3, this.state);
            if (this.count != 0)
                writer.writeUint32(4, this.count);
            if (this.id.length)
                writer.writeRepeatedString(5, this.id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ComputeTabletStatus {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ComputeTabletStatus();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.overall = reader.readEnum();
                        break;
                    case 2:
                        message.type = reader.readString();
                        break;
                    case 3:
                        message.state = reader.readString();
                        break;
                    case 4:
                        message.count = reader.readUint32();
                        break;
                    case 5:
                        pb_1.Message.addToRepeatedField(message, 5, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ComputeTabletStatus {
            return ComputeTabletStatus.deserialize(bytes);
        }
    }
    export class ThreadPoolStatus extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            overall?: StatusFlag.Status;
            name?: string;
            usage?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("overall" in data && data.overall != undefined) {
                    this.overall = data.overall;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("usage" in data && data.usage != undefined) {
                    this.usage = data.usage;
                }
            }
        }
        get overall() {
            return pb_1.Message.getFieldWithDefault(this, 1, StatusFlag.Status.UNSPECIFIED) as StatusFlag.Status;
        }
        set overall(value: StatusFlag.Status) {
            pb_1.Message.setField(this, 1, value);
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get usage() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set usage(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            overall?: StatusFlag.Status;
            name?: string;
            usage?: number;
        }): ThreadPoolStatus {
            const message = new ThreadPoolStatus({});
            if (data.overall != null) {
                message.overall = data.overall;
            }
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.usage != null) {
                message.usage = data.usage;
            }
            return message;
        }
        toObject() {
            const data: {
                overall?: StatusFlag.Status;
                name?: string;
                usage?: number;
            } = {};
            if (this.overall != null) {
                data.overall = this.overall;
            }
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.usage != null) {
                data.usage = this.usage;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.overall != StatusFlag.Status.UNSPECIFIED)
                writer.writeEnum(1, this.overall);
            if (this.name.length)
                writer.writeString(2, this.name);
            if (this.usage != 0)
                writer.writeFloat(3, this.usage);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ThreadPoolStatus {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ThreadPoolStatus();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.overall = reader.readEnum();
                        break;
                    case 2:
                        message.name = reader.readString();
                        break;
                    case 3:
                        message.usage = reader.readFloat();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ThreadPoolStatus {
            return ThreadPoolStatus.deserialize(bytes);
        }
    }
    export class LoadAverageStatus extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            overall?: StatusFlag.Status;
            load?: number;
            cores?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("overall" in data && data.overall != undefined) {
                    this.overall = data.overall;
                }
                if ("load" in data && data.load != undefined) {
                    this.load = data.load;
                }
                if ("cores" in data && data.cores != undefined) {
                    this.cores = data.cores;
                }
            }
        }
        get overall() {
            return pb_1.Message.getFieldWithDefault(this, 1, StatusFlag.Status.UNSPECIFIED) as StatusFlag.Status;
        }
        set overall(value: StatusFlag.Status) {
            pb_1.Message.setField(this, 1, value);
        }
        get load() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set load(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get cores() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set cores(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            overall?: StatusFlag.Status;
            load?: number;
            cores?: number;
        }): LoadAverageStatus {
            const message = new LoadAverageStatus({});
            if (data.overall != null) {
                message.overall = data.overall;
            }
            if (data.load != null) {
                message.load = data.load;
            }
            if (data.cores != null) {
                message.cores = data.cores;
            }
            return message;
        }
        toObject() {
            const data: {
                overall?: StatusFlag.Status;
                load?: number;
                cores?: number;
            } = {};
            if (this.overall != null) {
                data.overall = this.overall;
            }
            if (this.load != null) {
                data.load = this.load;
            }
            if (this.cores != null) {
                data.cores = this.cores;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.overall != StatusFlag.Status.UNSPECIFIED)
                writer.writeEnum(1, this.overall);
            if (this.load != 0)
                writer.writeFloat(2, this.load);
            if (this.cores != 0)
                writer.writeUint32(3, this.cores);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LoadAverageStatus {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LoadAverageStatus();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.overall = reader.readEnum();
                        break;
                    case 2:
                        message.load = reader.readFloat();
                        break;
                    case 3:
                        message.cores = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LoadAverageStatus {
            return LoadAverageStatus.deserialize(bytes);
        }
    }
    export class ComputeNodeStatus extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: string;
            overall?: StatusFlag.Status;
            tablets?: ComputeTabletStatus[];
            pools?: ThreadPoolStatus[];
            load?: LoadAverageStatus;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3, 4], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("overall" in data && data.overall != undefined) {
                    this.overall = data.overall;
                }
                if ("tablets" in data && data.tablets != undefined) {
                    this.tablets = data.tablets;
                }
                if ("pools" in data && data.pools != undefined) {
                    this.pools = data.pools;
                }
                if ("load" in data && data.load != undefined) {
                    this.load = data.load;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get overall() {
            return pb_1.Message.getFieldWithDefault(this, 2, StatusFlag.Status.UNSPECIFIED) as StatusFlag.Status;
        }
        set overall(value: StatusFlag.Status) {
            pb_1.Message.setField(this, 2, value);
        }
        get tablets() {
            return pb_1.Message.getRepeatedWrapperField(this, ComputeTabletStatus, 3) as ComputeTabletStatus[];
        }
        set tablets(value: ComputeTabletStatus[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        get pools() {
            return pb_1.Message.getRepeatedWrapperField(this, ThreadPoolStatus, 4) as ThreadPoolStatus[];
        }
        set pools(value: ThreadPoolStatus[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        get load() {
            return pb_1.Message.getWrapperField(this, LoadAverageStatus, 5) as LoadAverageStatus;
        }
        set load(value: LoadAverageStatus) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        get has_load() {
            return pb_1.Message.getField(this, 5) != null;
        }
        static fromObject(data: {
            id?: string;
            overall?: StatusFlag.Status;
            tablets?: ReturnType<typeof ComputeTabletStatus.prototype.toObject>[];
            pools?: ReturnType<typeof ThreadPoolStatus.prototype.toObject>[];
            load?: ReturnType<typeof LoadAverageStatus.prototype.toObject>;
        }): ComputeNodeStatus {
            const message = new ComputeNodeStatus({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.overall != null) {
                message.overall = data.overall;
            }
            if (data.tablets != null) {
                message.tablets = data.tablets.map(item => ComputeTabletStatus.fromObject(item));
            }
            if (data.pools != null) {
                message.pools = data.pools.map(item => ThreadPoolStatus.fromObject(item));
            }
            if (data.load != null) {
                message.load = LoadAverageStatus.fromObject(data.load);
            }
            return message;
        }
        toObject() {
            const data: {
                id?: string;
                overall?: StatusFlag.Status;
                tablets?: ReturnType<typeof ComputeTabletStatus.prototype.toObject>[];
                pools?: ReturnType<typeof ThreadPoolStatus.prototype.toObject>[];
                load?: ReturnType<typeof LoadAverageStatus.prototype.toObject>;
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.overall != null) {
                data.overall = this.overall;
            }
            if (this.tablets != null) {
                data.tablets = this.tablets.map((item: ComputeTabletStatus) => item.toObject());
            }
            if (this.pools != null) {
                data.pools = this.pools.map((item: ThreadPoolStatus) => item.toObject());
            }
            if (this.load != null) {
                data.load = this.load.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id.length)
                writer.writeString(1, this.id);
            if (this.overall != StatusFlag.Status.UNSPECIFIED)
                writer.writeEnum(2, this.overall);
            if (this.tablets.length)
                writer.writeRepeatedMessage(3, this.tablets, (item: ComputeTabletStatus) => item.serialize(writer));
            if (this.pools.length)
                writer.writeRepeatedMessage(4, this.pools, (item: ThreadPoolStatus) => item.serialize(writer));
            if (this.has_load)
                writer.writeMessage(5, this.load, () => this.load.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ComputeNodeStatus {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ComputeNodeStatus();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readString();
                        break;
                    case 2:
                        message.overall = reader.readEnum();
                        break;
                    case 3:
                        reader.readMessage(message.tablets, () => pb_1.Message.addToRepeatedWrapperField(message, 3, ComputeTabletStatus.deserialize(reader), ComputeTabletStatus));
                        break;
                    case 4:
                        reader.readMessage(message.pools, () => pb_1.Message.addToRepeatedWrapperField(message, 4, ThreadPoolStatus.deserialize(reader), ThreadPoolStatus));
                        break;
                    case 5:
                        reader.readMessage(message.load, () => message.load = LoadAverageStatus.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ComputeNodeStatus {
            return ComputeNodeStatus.deserialize(bytes);
        }
    }
    export class ComputeStatus extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            overall?: StatusFlag.Status;
            nodes?: ComputeNodeStatus[];
            tablets?: ComputeTabletStatus[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("overall" in data && data.overall != undefined) {
                    this.overall = data.overall;
                }
                if ("nodes" in data && data.nodes != undefined) {
                    this.nodes = data.nodes;
                }
                if ("tablets" in data && data.tablets != undefined) {
                    this.tablets = data.tablets;
                }
            }
        }
        get overall() {
            return pb_1.Message.getFieldWithDefault(this, 1, StatusFlag.Status.UNSPECIFIED) as StatusFlag.Status;
        }
        set overall(value: StatusFlag.Status) {
            pb_1.Message.setField(this, 1, value);
        }
        get nodes() {
            return pb_1.Message.getRepeatedWrapperField(this, ComputeNodeStatus, 2) as ComputeNodeStatus[];
        }
        set nodes(value: ComputeNodeStatus[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get tablets() {
            return pb_1.Message.getRepeatedWrapperField(this, ComputeTabletStatus, 3) as ComputeTabletStatus[];
        }
        set tablets(value: ComputeTabletStatus[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        static fromObject(data: {
            overall?: StatusFlag.Status;
            nodes?: ReturnType<typeof ComputeNodeStatus.prototype.toObject>[];
            tablets?: ReturnType<typeof ComputeTabletStatus.prototype.toObject>[];
        }): ComputeStatus {
            const message = new ComputeStatus({});
            if (data.overall != null) {
                message.overall = data.overall;
            }
            if (data.nodes != null) {
                message.nodes = data.nodes.map(item => ComputeNodeStatus.fromObject(item));
            }
            if (data.tablets != null) {
                message.tablets = data.tablets.map(item => ComputeTabletStatus.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                overall?: StatusFlag.Status;
                nodes?: ReturnType<typeof ComputeNodeStatus.prototype.toObject>[];
                tablets?: ReturnType<typeof ComputeTabletStatus.prototype.toObject>[];
            } = {};
            if (this.overall != null) {
                data.overall = this.overall;
            }
            if (this.nodes != null) {
                data.nodes = this.nodes.map((item: ComputeNodeStatus) => item.toObject());
            }
            if (this.tablets != null) {
                data.tablets = this.tablets.map((item: ComputeTabletStatus) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.overall != StatusFlag.Status.UNSPECIFIED)
                writer.writeEnum(1, this.overall);
            if (this.nodes.length)
                writer.writeRepeatedMessage(2, this.nodes, (item: ComputeNodeStatus) => item.serialize(writer));
            if (this.tablets.length)
                writer.writeRepeatedMessage(3, this.tablets, (item: ComputeTabletStatus) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ComputeStatus {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ComputeStatus();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.overall = reader.readEnum();
                        break;
                    case 2:
                        reader.readMessage(message.nodes, () => pb_1.Message.addToRepeatedWrapperField(message, 2, ComputeNodeStatus.deserialize(reader), ComputeNodeStatus));
                        break;
                    case 3:
                        reader.readMessage(message.tablets, () => pb_1.Message.addToRepeatedWrapperField(message, 3, ComputeTabletStatus.deserialize(reader), ComputeTabletStatus));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ComputeStatus {
            return ComputeStatus.deserialize(bytes);
        }
    }
    export class LocationNode extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: number;
            host?: string;
            port?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("host" in data && data.host != undefined) {
                    this.host = data.host;
                }
                if ("port" in data && data.port != undefined) {
                    this.port = data.port;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get host() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set host(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get port() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set port(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            id?: number;
            host?: string;
            port?: number;
        }): LocationNode {
            const message = new LocationNode({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.host != null) {
                message.host = data.host;
            }
            if (data.port != null) {
                message.port = data.port;
            }
            return message;
        }
        toObject() {
            const data: {
                id?: number;
                host?: string;
                port?: number;
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.host != null) {
                data.host = this.host;
            }
            if (this.port != null) {
                data.port = this.port;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id != 0)
                writer.writeUint32(1, this.id);
            if (this.host.length)
                writer.writeString(2, this.host);
            if (this.port != 0)
                writer.writeUint32(3, this.port);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LocationNode {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LocationNode();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readUint32();
                        break;
                    case 2:
                        message.host = reader.readString();
                        break;
                    case 3:
                        message.port = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LocationNode {
            return LocationNode.deserialize(bytes);
        }
    }
    export class LocationStoragePDisk extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: string;
            path?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("path" in data && data.path != undefined) {
                    this.path = data.path;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get path() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set path(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            id?: string;
            path?: string;
        }): LocationStoragePDisk {
            const message = new LocationStoragePDisk({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.path != null) {
                message.path = data.path;
            }
            return message;
        }
        toObject() {
            const data: {
                id?: string;
                path?: string;
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.path != null) {
                data.path = this.path;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id.length)
                writer.writeString(1, this.id);
            if (this.path.length)
                writer.writeString(2, this.path);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LocationStoragePDisk {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LocationStoragePDisk();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readString();
                        break;
                    case 2:
                        message.path = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LocationStoragePDisk {
            return LocationStoragePDisk.deserialize(bytes);
        }
    }
    export class LocationStorageVDisk extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: string[];
            pdisk?: LocationStoragePDisk[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("pdisk" in data && data.pdisk != undefined) {
                    this.pdisk = data.pdisk;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set id(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        get pdisk() {
            return pb_1.Message.getRepeatedWrapperField(this, LocationStoragePDisk, 2) as LocationStoragePDisk[];
        }
        set pdisk(value: LocationStoragePDisk[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            id?: string[];
            pdisk?: ReturnType<typeof LocationStoragePDisk.prototype.toObject>[];
        }): LocationStorageVDisk {
            const message = new LocationStorageVDisk({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.pdisk != null) {
                message.pdisk = data.pdisk.map(item => LocationStoragePDisk.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                id?: string[];
                pdisk?: ReturnType<typeof LocationStoragePDisk.prototype.toObject>[];
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.pdisk != null) {
                data.pdisk = this.pdisk.map((item: LocationStoragePDisk) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id.length)
                writer.writeRepeatedString(1, this.id);
            if (this.pdisk.length)
                writer.writeRepeatedMessage(2, this.pdisk, (item: LocationStoragePDisk) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LocationStorageVDisk {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LocationStorageVDisk();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    case 2:
                        reader.readMessage(message.pdisk, () => pb_1.Message.addToRepeatedWrapperField(message, 2, LocationStoragePDisk.deserialize(reader), LocationStoragePDisk));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LocationStorageVDisk {
            return LocationStorageVDisk.deserialize(bytes);
        }
    }
    export class LocationStorageGroup extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: string[];
            vdisk?: LocationStorageVDisk;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("vdisk" in data && data.vdisk != undefined) {
                    this.vdisk = data.vdisk;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set id(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        get vdisk() {
            return pb_1.Message.getWrapperField(this, LocationStorageVDisk, 2) as LocationStorageVDisk;
        }
        set vdisk(value: LocationStorageVDisk) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_vdisk() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            id?: string[];
            vdisk?: ReturnType<typeof LocationStorageVDisk.prototype.toObject>;
        }): LocationStorageGroup {
            const message = new LocationStorageGroup({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.vdisk != null) {
                message.vdisk = LocationStorageVDisk.fromObject(data.vdisk);
            }
            return message;
        }
        toObject() {
            const data: {
                id?: string[];
                vdisk?: ReturnType<typeof LocationStorageVDisk.prototype.toObject>;
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.vdisk != null) {
                data.vdisk = this.vdisk.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id.length)
                writer.writeRepeatedString(1, this.id);
            if (this.has_vdisk)
                writer.writeMessage(2, this.vdisk, () => this.vdisk.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LocationStorageGroup {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LocationStorageGroup();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    case 2:
                        reader.readMessage(message.vdisk, () => message.vdisk = LocationStorageVDisk.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LocationStorageGroup {
            return LocationStorageGroup.deserialize(bytes);
        }
    }
    export class LocationStoragePool extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            group?: LocationStorageGroup;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("group" in data && data.group != undefined) {
                    this.group = data.group;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get group() {
            return pb_1.Message.getWrapperField(this, LocationStorageGroup, 2) as LocationStorageGroup;
        }
        set group(value: LocationStorageGroup) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_group() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            name?: string;
            group?: ReturnType<typeof LocationStorageGroup.prototype.toObject>;
        }): LocationStoragePool {
            const message = new LocationStoragePool({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.group != null) {
                message.group = LocationStorageGroup.fromObject(data.group);
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                group?: ReturnType<typeof LocationStorageGroup.prototype.toObject>;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.group != null) {
                data.group = this.group.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.has_group)
                writer.writeMessage(2, this.group, () => this.group.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LocationStoragePool {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LocationStoragePool();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.group, () => message.group = LocationStorageGroup.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LocationStoragePool {
            return LocationStoragePool.deserialize(bytes);
        }
    }
    export class LocationStorage extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            node?: LocationNode;
            pool?: LocationStoragePool;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("node" in data && data.node != undefined) {
                    this.node = data.node;
                }
                if ("pool" in data && data.pool != undefined) {
                    this.pool = data.pool;
                }
            }
        }
        get node() {
            return pb_1.Message.getWrapperField(this, LocationNode, 1) as LocationNode;
        }
        set node(value: LocationNode) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_node() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get pool() {
            return pb_1.Message.getWrapperField(this, LocationStoragePool, 2) as LocationStoragePool;
        }
        set pool(value: LocationStoragePool) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_pool() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            node?: ReturnType<typeof LocationNode.prototype.toObject>;
            pool?: ReturnType<typeof LocationStoragePool.prototype.toObject>;
        }): LocationStorage {
            const message = new LocationStorage({});
            if (data.node != null) {
                message.node = LocationNode.fromObject(data.node);
            }
            if (data.pool != null) {
                message.pool = LocationStoragePool.fromObject(data.pool);
            }
            return message;
        }
        toObject() {
            const data: {
                node?: ReturnType<typeof LocationNode.prototype.toObject>;
                pool?: ReturnType<typeof LocationStoragePool.prototype.toObject>;
            } = {};
            if (this.node != null) {
                data.node = this.node.toObject();
            }
            if (this.pool != null) {
                data.pool = this.pool.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_node)
                writer.writeMessage(1, this.node, () => this.node.serialize(writer));
            if (this.has_pool)
                writer.writeMessage(2, this.pool, () => this.pool.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LocationStorage {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LocationStorage();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.node, () => message.node = LocationNode.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.pool, () => message.pool = LocationStoragePool.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LocationStorage {
            return LocationStorage.deserialize(bytes);
        }
    }
    export class LocationComputePool extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            name?: string;
        }): LocationComputePool {
            const message = new LocationComputePool({});
            if (data.name != null) {
                message.name = data.name;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LocationComputePool {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LocationComputePool();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LocationComputePool {
            return LocationComputePool.deserialize(bytes);
        }
    }
    export class LocationComputeTablet extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: string;
            id?: string[];
            count?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("count" in data && data.count != undefined) {
                    this.count = data.count;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set type(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
        }
        set id(value: string[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get count() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set count(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            type?: string;
            id?: string[];
            count?: number;
        }): LocationComputeTablet {
            const message = new LocationComputeTablet({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.count != null) {
                message.count = data.count;
            }
            return message;
        }
        toObject() {
            const data: {
                type?: string;
                id?: string[];
                count?: number;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.count != null) {
                data.count = this.count;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type.length)
                writer.writeString(1, this.type);
            if (this.id.length)
                writer.writeRepeatedString(2, this.id);
            if (this.count != 0)
                writer.writeUint32(3, this.count);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LocationComputeTablet {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LocationComputeTablet();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readString();
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                        break;
                    case 3:
                        message.count = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LocationComputeTablet {
            return LocationComputeTablet.deserialize(bytes);
        }
    }
    export class LocationCompute extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            node?: LocationNode;
            pool?: LocationComputePool;
            tablet?: LocationComputeTablet;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("node" in data && data.node != undefined) {
                    this.node = data.node;
                }
                if ("pool" in data && data.pool != undefined) {
                    this.pool = data.pool;
                }
                if ("tablet" in data && data.tablet != undefined) {
                    this.tablet = data.tablet;
                }
            }
        }
        get node() {
            return pb_1.Message.getWrapperField(this, LocationNode, 1) as LocationNode;
        }
        set node(value: LocationNode) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_node() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get pool() {
            return pb_1.Message.getWrapperField(this, LocationComputePool, 2) as LocationComputePool;
        }
        set pool(value: LocationComputePool) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_pool() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get tablet() {
            return pb_1.Message.getWrapperField(this, LocationComputeTablet, 3) as LocationComputeTablet;
        }
        set tablet(value: LocationComputeTablet) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_tablet() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            node?: ReturnType<typeof LocationNode.prototype.toObject>;
            pool?: ReturnType<typeof LocationComputePool.prototype.toObject>;
            tablet?: ReturnType<typeof LocationComputeTablet.prototype.toObject>;
        }): LocationCompute {
            const message = new LocationCompute({});
            if (data.node != null) {
                message.node = LocationNode.fromObject(data.node);
            }
            if (data.pool != null) {
                message.pool = LocationComputePool.fromObject(data.pool);
            }
            if (data.tablet != null) {
                message.tablet = LocationComputeTablet.fromObject(data.tablet);
            }
            return message;
        }
        toObject() {
            const data: {
                node?: ReturnType<typeof LocationNode.prototype.toObject>;
                pool?: ReturnType<typeof LocationComputePool.prototype.toObject>;
                tablet?: ReturnType<typeof LocationComputeTablet.prototype.toObject>;
            } = {};
            if (this.node != null) {
                data.node = this.node.toObject();
            }
            if (this.pool != null) {
                data.pool = this.pool.toObject();
            }
            if (this.tablet != null) {
                data.tablet = this.tablet.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_node)
                writer.writeMessage(1, this.node, () => this.node.serialize(writer));
            if (this.has_pool)
                writer.writeMessage(2, this.pool, () => this.pool.serialize(writer));
            if (this.has_tablet)
                writer.writeMessage(3, this.tablet, () => this.tablet.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LocationCompute {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LocationCompute();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.node, () => message.node = LocationNode.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.pool, () => message.pool = LocationComputePool.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.tablet, () => message.tablet = LocationComputeTablet.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LocationCompute {
            return LocationCompute.deserialize(bytes);
        }
    }
    export class LocationDatabase extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            name?: string;
        }): LocationDatabase {
            const message = new LocationDatabase({});
            if (data.name != null) {
                message.name = data.name;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LocationDatabase {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LocationDatabase();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LocationDatabase {
            return LocationDatabase.deserialize(bytes);
        }
    }
    export class Location extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            storage?: LocationStorage;
            compute?: LocationCompute;
            database?: LocationDatabase;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("storage" in data && data.storage != undefined) {
                    this.storage = data.storage;
                }
                if ("compute" in data && data.compute != undefined) {
                    this.compute = data.compute;
                }
                if ("database" in data && data.database != undefined) {
                    this.database = data.database;
                }
            }
        }
        get storage() {
            return pb_1.Message.getWrapperField(this, LocationStorage, 1) as LocationStorage;
        }
        set storage(value: LocationStorage) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_storage() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get compute() {
            return pb_1.Message.getWrapperField(this, LocationCompute, 2) as LocationCompute;
        }
        set compute(value: LocationCompute) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_compute() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get database() {
            return pb_1.Message.getWrapperField(this, LocationDatabase, 3) as LocationDatabase;
        }
        set database(value: LocationDatabase) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_database() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            storage?: ReturnType<typeof LocationStorage.prototype.toObject>;
            compute?: ReturnType<typeof LocationCompute.prototype.toObject>;
            database?: ReturnType<typeof LocationDatabase.prototype.toObject>;
        }): Location {
            const message = new Location({});
            if (data.storage != null) {
                message.storage = LocationStorage.fromObject(data.storage);
            }
            if (data.compute != null) {
                message.compute = LocationCompute.fromObject(data.compute);
            }
            if (data.database != null) {
                message.database = LocationDatabase.fromObject(data.database);
            }
            return message;
        }
        toObject() {
            const data: {
                storage?: ReturnType<typeof LocationStorage.prototype.toObject>;
                compute?: ReturnType<typeof LocationCompute.prototype.toObject>;
                database?: ReturnType<typeof LocationDatabase.prototype.toObject>;
            } = {};
            if (this.storage != null) {
                data.storage = this.storage.toObject();
            }
            if (this.compute != null) {
                data.compute = this.compute.toObject();
            }
            if (this.database != null) {
                data.database = this.database.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_storage)
                writer.writeMessage(1, this.storage, () => this.storage.serialize(writer));
            if (this.has_compute)
                writer.writeMessage(2, this.compute, () => this.compute.serialize(writer));
            if (this.has_database)
                writer.writeMessage(3, this.database, () => this.database.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Location {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Location();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.storage, () => message.storage = LocationStorage.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.compute, () => message.compute = LocationCompute.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.database, () => message.database = LocationDatabase.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Location {
            return Location.deserialize(bytes);
        }
    }
    export class IssueLog extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: string;
            status?: StatusFlag.Status;
            message?: string;
            location?: Location;
            reason?: string[];
            type?: string;
            level?: number;
            listed?: number;
            count?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("status" in data && data.status != undefined) {
                    this.status = data.status;
                }
                if ("message" in data && data.message != undefined) {
                    this.message = data.message;
                }
                if ("location" in data && data.location != undefined) {
                    this.location = data.location;
                }
                if ("reason" in data && data.reason != undefined) {
                    this.reason = data.reason;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("level" in data && data.level != undefined) {
                    this.level = data.level;
                }
                if ("listed" in data && data.listed != undefined) {
                    this.listed = data.listed;
                }
                if ("count" in data && data.count != undefined) {
                    this.count = data.count;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get status() {
            return pb_1.Message.getFieldWithDefault(this, 2, StatusFlag.Status.UNSPECIFIED) as StatusFlag.Status;
        }
        set status(value: StatusFlag.Status) {
            pb_1.Message.setField(this, 2, value);
        }
        get message() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set message(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get location() {
            return pb_1.Message.getWrapperField(this, Location, 4) as Location;
        }
        set location(value: Location) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_location() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get reason() {
            return pb_1.Message.getFieldWithDefault(this, 5, []) as string[];
        }
        set reason(value: string[]) {
            pb_1.Message.setField(this, 5, value);
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
        }
        set type(value: string) {
            pb_1.Message.setField(this, 6, value);
        }
        get level() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set level(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get listed() {
            return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
        }
        set listed(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        get count() {
            return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
        }
        set count(value: number) {
            pb_1.Message.setField(this, 9, value);
        }
        static fromObject(data: {
            id?: string;
            status?: StatusFlag.Status;
            message?: string;
            location?: ReturnType<typeof Location.prototype.toObject>;
            reason?: string[];
            type?: string;
            level?: number;
            listed?: number;
            count?: number;
        }): IssueLog {
            const message = new IssueLog({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.status != null) {
                message.status = data.status;
            }
            if (data.message != null) {
                message.message = data.message;
            }
            if (data.location != null) {
                message.location = Location.fromObject(data.location);
            }
            if (data.reason != null) {
                message.reason = data.reason;
            }
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.level != null) {
                message.level = data.level;
            }
            if (data.listed != null) {
                message.listed = data.listed;
            }
            if (data.count != null) {
                message.count = data.count;
            }
            return message;
        }
        toObject() {
            const data: {
                id?: string;
                status?: StatusFlag.Status;
                message?: string;
                location?: ReturnType<typeof Location.prototype.toObject>;
                reason?: string[];
                type?: string;
                level?: number;
                listed?: number;
                count?: number;
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.status != null) {
                data.status = this.status;
            }
            if (this.message != null) {
                data.message = this.message;
            }
            if (this.location != null) {
                data.location = this.location.toObject();
            }
            if (this.reason != null) {
                data.reason = this.reason;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.level != null) {
                data.level = this.level;
            }
            if (this.listed != null) {
                data.listed = this.listed;
            }
            if (this.count != null) {
                data.count = this.count;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id.length)
                writer.writeString(1, this.id);
            if (this.status != StatusFlag.Status.UNSPECIFIED)
                writer.writeEnum(2, this.status);
            if (this.message.length)
                writer.writeString(3, this.message);
            if (this.has_location)
                writer.writeMessage(4, this.location, () => this.location.serialize(writer));
            if (this.reason.length)
                writer.writeRepeatedString(5, this.reason);
            if (this.type.length)
                writer.writeString(6, this.type);
            if (this.level != 0)
                writer.writeUint32(7, this.level);
            if (this.listed != 0)
                writer.writeUint32(8, this.listed);
            if (this.count != 0)
                writer.writeUint32(9, this.count);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IssueLog {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IssueLog();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readString();
                        break;
                    case 2:
                        message.status = reader.readEnum();
                        break;
                    case 3:
                        message.message = reader.readString();
                        break;
                    case 4:
                        reader.readMessage(message.location, () => message.location = Location.deserialize(reader));
                        break;
                    case 5:
                        pb_1.Message.addToRepeatedField(message, 5, reader.readString());
                        break;
                    case 6:
                        message.type = reader.readString();
                        break;
                    case 7:
                        message.level = reader.readUint32();
                        break;
                    case 8:
                        message.listed = reader.readUint32();
                        break;
                    case 9:
                        message.count = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IssueLog {
            return IssueLog.deserialize(bytes);
        }
    }
    export class DatabaseStatus extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            overall?: StatusFlag.Status;
            storage?: StorageStatus;
            compute?: ComputeStatus;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("overall" in data && data.overall != undefined) {
                    this.overall = data.overall;
                }
                if ("storage" in data && data.storage != undefined) {
                    this.storage = data.storage;
                }
                if ("compute" in data && data.compute != undefined) {
                    this.compute = data.compute;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get overall() {
            return pb_1.Message.getFieldWithDefault(this, 2, StatusFlag.Status.UNSPECIFIED) as StatusFlag.Status;
        }
        set overall(value: StatusFlag.Status) {
            pb_1.Message.setField(this, 2, value);
        }
        get storage() {
            return pb_1.Message.getWrapperField(this, StorageStatus, 3) as StorageStatus;
        }
        set storage(value: StorageStatus) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_storage() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get compute() {
            return pb_1.Message.getWrapperField(this, ComputeStatus, 4) as ComputeStatus;
        }
        set compute(value: ComputeStatus) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_compute() {
            return pb_1.Message.getField(this, 4) != null;
        }
        static fromObject(data: {
            name?: string;
            overall?: StatusFlag.Status;
            storage?: ReturnType<typeof StorageStatus.prototype.toObject>;
            compute?: ReturnType<typeof ComputeStatus.prototype.toObject>;
        }): DatabaseStatus {
            const message = new DatabaseStatus({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.overall != null) {
                message.overall = data.overall;
            }
            if (data.storage != null) {
                message.storage = StorageStatus.fromObject(data.storage);
            }
            if (data.compute != null) {
                message.compute = ComputeStatus.fromObject(data.compute);
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                overall?: StatusFlag.Status;
                storage?: ReturnType<typeof StorageStatus.prototype.toObject>;
                compute?: ReturnType<typeof ComputeStatus.prototype.toObject>;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.overall != null) {
                data.overall = this.overall;
            }
            if (this.storage != null) {
                data.storage = this.storage.toObject();
            }
            if (this.compute != null) {
                data.compute = this.compute.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.overall != StatusFlag.Status.UNSPECIFIED)
                writer.writeEnum(2, this.overall);
            if (this.has_storage)
                writer.writeMessage(3, this.storage, () => this.storage.serialize(writer));
            if (this.has_compute)
                writer.writeMessage(4, this.compute, () => this.compute.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DatabaseStatus {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DatabaseStatus();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.overall = reader.readEnum();
                        break;
                    case 3:
                        reader.readMessage(message.storage, () => message.storage = StorageStatus.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.compute, () => message.compute = ComputeStatus.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DatabaseStatus {
            return DatabaseStatus.deserialize(bytes);
        }
    }
    export class SelfCheckResult extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            self_check_result?: SelfCheck.Result;
            issue_log?: IssueLog[];
            database_status?: DatabaseStatus[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("self_check_result" in data && data.self_check_result != undefined) {
                    this.self_check_result = data.self_check_result;
                }
                if ("issue_log" in data && data.issue_log != undefined) {
                    this.issue_log = data.issue_log;
                }
                if ("database_status" in data && data.database_status != undefined) {
                    this.database_status = data.database_status;
                }
            }
        }
        get self_check_result() {
            return pb_1.Message.getFieldWithDefault(this, 1, SelfCheck.Result.UNSPECIFIED) as SelfCheck.Result;
        }
        set self_check_result(value: SelfCheck.Result) {
            pb_1.Message.setField(this, 1, value);
        }
        get issue_log() {
            return pb_1.Message.getRepeatedWrapperField(this, IssueLog, 2) as IssueLog[];
        }
        set issue_log(value: IssueLog[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get database_status() {
            return pb_1.Message.getRepeatedWrapperField(this, DatabaseStatus, 3) as DatabaseStatus[];
        }
        set database_status(value: DatabaseStatus[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        static fromObject(data: {
            self_check_result?: SelfCheck.Result;
            issue_log?: ReturnType<typeof IssueLog.prototype.toObject>[];
            database_status?: ReturnType<typeof DatabaseStatus.prototype.toObject>[];
        }): SelfCheckResult {
            const message = new SelfCheckResult({});
            if (data.self_check_result != null) {
                message.self_check_result = data.self_check_result;
            }
            if (data.issue_log != null) {
                message.issue_log = data.issue_log.map(item => IssueLog.fromObject(item));
            }
            if (data.database_status != null) {
                message.database_status = data.database_status.map(item => DatabaseStatus.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                self_check_result?: SelfCheck.Result;
                issue_log?: ReturnType<typeof IssueLog.prototype.toObject>[];
                database_status?: ReturnType<typeof DatabaseStatus.prototype.toObject>[];
            } = {};
            if (this.self_check_result != null) {
                data.self_check_result = this.self_check_result;
            }
            if (this.issue_log != null) {
                data.issue_log = this.issue_log.map((item: IssueLog) => item.toObject());
            }
            if (this.database_status != null) {
                data.database_status = this.database_status.map((item: DatabaseStatus) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.self_check_result != SelfCheck.Result.UNSPECIFIED)
                writer.writeEnum(1, this.self_check_result);
            if (this.issue_log.length)
                writer.writeRepeatedMessage(2, this.issue_log, (item: IssueLog) => item.serialize(writer));
            if (this.database_status.length)
                writer.writeRepeatedMessage(3, this.database_status, (item: DatabaseStatus) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SelfCheckResult {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SelfCheckResult();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.self_check_result = reader.readEnum();
                        break;
                    case 2:
                        reader.readMessage(message.issue_log, () => pb_1.Message.addToRepeatedWrapperField(message, 2, IssueLog.deserialize(reader), IssueLog));
                        break;
                    case 3:
                        reader.readMessage(message.database_status, () => pb_1.Message.addToRepeatedWrapperField(message, 3, DatabaseStatus.deserialize(reader), DatabaseStatus));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SelfCheckResult {
            return SelfCheckResult.deserialize(bytes);
        }
    }
}
