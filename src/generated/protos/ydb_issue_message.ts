/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 0.0.0
 * source: protos/ydb_issue_message.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace Ydb.Issue {
    export class IssueMessage extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            position?: IssueMessage.Position;
            message?: string;
            end_position?: IssueMessage.Position;
            issue_code?: number;
            severity?: number;
            issues?: IssueMessage[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [6], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("position" in data && data.position != undefined) {
                    this.position = data.position;
                }
                if ("message" in data && data.message != undefined) {
                    this.message = data.message;
                }
                if ("end_position" in data && data.end_position != undefined) {
                    this.end_position = data.end_position;
                }
                if ("issue_code" in data && data.issue_code != undefined) {
                    this.issue_code = data.issue_code;
                }
                if ("severity" in data && data.severity != undefined) {
                    this.severity = data.severity;
                }
                if ("issues" in data && data.issues != undefined) {
                    this.issues = data.issues;
                }
            }
        }
        get position() {
            return pb_1.Message.getWrapperField(this, IssueMessage.Position, 1) as IssueMessage.Position;
        }
        set position(value: IssueMessage.Position) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_position() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get message() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set message(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get end_position() {
            return pb_1.Message.getWrapperField(this, IssueMessage.Position, 3) as IssueMessage.Position;
        }
        set end_position(value: IssueMessage.Position) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_end_position() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get issue_code() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set issue_code(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get severity() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set severity(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get issues() {
            return pb_1.Message.getRepeatedWrapperField(this, IssueMessage, 6) as IssueMessage[];
        }
        set issues(value: IssueMessage[]) {
            pb_1.Message.setRepeatedWrapperField(this, 6, value);
        }
        static fromObject(data: {
            position?: ReturnType<typeof IssueMessage.Position.prototype.toObject>;
            message?: string;
            end_position?: ReturnType<typeof IssueMessage.Position.prototype.toObject>;
            issue_code?: number;
            severity?: number;
            issues?: ReturnType<typeof IssueMessage.prototype.toObject>[];
        }): IssueMessage {
            const message = new IssueMessage({});
            if (data.position != null) {
                message.position = IssueMessage.Position.fromObject(data.position);
            }
            if (data.message != null) {
                message.message = data.message;
            }
            if (data.end_position != null) {
                message.end_position = IssueMessage.Position.fromObject(data.end_position);
            }
            if (data.issue_code != null) {
                message.issue_code = data.issue_code;
            }
            if (data.severity != null) {
                message.severity = data.severity;
            }
            if (data.issues != null) {
                message.issues = data.issues.map(item => IssueMessage.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                position?: ReturnType<typeof IssueMessage.Position.prototype.toObject>;
                message?: string;
                end_position?: ReturnType<typeof IssueMessage.Position.prototype.toObject>;
                issue_code?: number;
                severity?: number;
                issues?: ReturnType<typeof IssueMessage.prototype.toObject>[];
            } = {};
            if (this.position != null) {
                data.position = this.position.toObject();
            }
            if (this.message != null) {
                data.message = this.message;
            }
            if (this.end_position != null) {
                data.end_position = this.end_position.toObject();
            }
            if (this.issue_code != null) {
                data.issue_code = this.issue_code;
            }
            if (this.severity != null) {
                data.severity = this.severity;
            }
            if (this.issues != null) {
                data.issues = this.issues.map((item: IssueMessage) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_position)
                writer.writeMessage(1, this.position, () => this.position.serialize(writer));
            if (this.message.length)
                writer.writeString(2, this.message);
            if (this.has_end_position)
                writer.writeMessage(3, this.end_position, () => this.end_position.serialize(writer));
            if (this.issue_code != 0)
                writer.writeUint32(4, this.issue_code);
            if (this.severity != 0)
                writer.writeUint32(5, this.severity);
            if (this.issues.length)
                writer.writeRepeatedMessage(6, this.issues, (item: IssueMessage) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IssueMessage {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IssueMessage();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.position, () => message.position = IssueMessage.Position.deserialize(reader));
                        break;
                    case 2:
                        message.message = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.end_position, () => message.end_position = IssueMessage.Position.deserialize(reader));
                        break;
                    case 4:
                        message.issue_code = reader.readUint32();
                        break;
                    case 5:
                        message.severity = reader.readUint32();
                        break;
                    case 6:
                        reader.readMessage(message.issues, () => pb_1.Message.addToRepeatedWrapperField(message, 6, IssueMessage.deserialize(reader), IssueMessage));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IssueMessage {
            return IssueMessage.deserialize(bytes);
        }
    }
    export namespace IssueMessage {
        export class Position extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                row?: number;
                column?: number;
                file?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("row" in data && data.row != undefined) {
                        this.row = data.row;
                    }
                    if ("column" in data && data.column != undefined) {
                        this.column = data.column;
                    }
                    if ("file" in data && data.file != undefined) {
                        this.file = data.file;
                    }
                }
            }
            get row() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set row(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get column() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set column(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get file() {
                return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
            }
            set file(value: string) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                row?: number;
                column?: number;
                file?: string;
            }): Position {
                const message = new Position({});
                if (data.row != null) {
                    message.row = data.row;
                }
                if (data.column != null) {
                    message.column = data.column;
                }
                if (data.file != null) {
                    message.file = data.file;
                }
                return message;
            }
            toObject() {
                const data: {
                    row?: number;
                    column?: number;
                    file?: string;
                } = {};
                if (this.row != null) {
                    data.row = this.row;
                }
                if (this.column != null) {
                    data.column = this.column;
                }
                if (this.file != null) {
                    data.file = this.file;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.row != 0)
                    writer.writeUint32(1, this.row);
                if (this.column != 0)
                    writer.writeUint32(2, this.column);
                if (this.file.length)
                    writer.writeString(3, this.file);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Position {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Position();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.row = reader.readUint32();
                            break;
                        case 2:
                            message.column = reader.readUint32();
                            break;
                        case 3:
                            message.file = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Position {
                return Position.deserialize(bytes);
            }
        }
    }
}
