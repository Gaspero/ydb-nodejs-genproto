/* eslint-disable */
import * as Long from "long";
import * as _m0 from "protobufjs/minimal";
import { IssueMessage } from "./ydb_issue_message";
import { Operation, OperationParams } from "./ydb_operation";
import { Entry } from "./ydb_scheme";
import { StatusIds_StatusCode, statusIds_StatusCodeFromJSON, statusIds_StatusCodeToJSON } from "./ydb_status_codes";

export const protobufPackage = "Ydb.Coordination";

/** Consistency mode */
export enum ConsistencyMode {
  /** CONSISTENCY_MODE_UNSET - The default or current value */
  CONSISTENCY_MODE_UNSET = 0,
  /** CONSISTENCY_MODE_STRICT - Strict mode makes sure operations may only complete on current leader */
  CONSISTENCY_MODE_STRICT = 1,
  /** CONSISTENCY_MODE_RELAXED - Relaxed mode allows operations to complete on stale masters */
  CONSISTENCY_MODE_RELAXED = 2,
  UNRECOGNIZED = -1,
}

export function consistencyModeFromJSON(object: any): ConsistencyMode {
  switch (object) {
    case 0:
    case "CONSISTENCY_MODE_UNSET":
      return ConsistencyMode.CONSISTENCY_MODE_UNSET;
    case 1:
    case "CONSISTENCY_MODE_STRICT":
      return ConsistencyMode.CONSISTENCY_MODE_STRICT;
    case 2:
    case "CONSISTENCY_MODE_RELAXED":
      return ConsistencyMode.CONSISTENCY_MODE_RELAXED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConsistencyMode.UNRECOGNIZED;
  }
}

export function consistencyModeToJSON(object: ConsistencyMode): string {
  switch (object) {
    case ConsistencyMode.CONSISTENCY_MODE_UNSET:
      return "CONSISTENCY_MODE_UNSET";
    case ConsistencyMode.CONSISTENCY_MODE_STRICT:
      return "CONSISTENCY_MODE_STRICT";
    case ConsistencyMode.CONSISTENCY_MODE_RELAXED:
      return "CONSISTENCY_MODE_RELAXED";
    case ConsistencyMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Counters mode */
export enum RateLimiterCountersMode {
  /** RATE_LIMITER_COUNTERS_MODE_UNSET - The default or current value */
  RATE_LIMITER_COUNTERS_MODE_UNSET = 0,
  /** RATE_LIMITER_COUNTERS_MODE_AGGREGATED - Aggregated counters for resource tree */
  RATE_LIMITER_COUNTERS_MODE_AGGREGATED = 1,
  /** RATE_LIMITER_COUNTERS_MODE_DETAILED - Counters on every resource */
  RATE_LIMITER_COUNTERS_MODE_DETAILED = 2,
  UNRECOGNIZED = -1,
}

export function rateLimiterCountersModeFromJSON(object: any): RateLimiterCountersMode {
  switch (object) {
    case 0:
    case "RATE_LIMITER_COUNTERS_MODE_UNSET":
      return RateLimiterCountersMode.RATE_LIMITER_COUNTERS_MODE_UNSET;
    case 1:
    case "RATE_LIMITER_COUNTERS_MODE_AGGREGATED":
      return RateLimiterCountersMode.RATE_LIMITER_COUNTERS_MODE_AGGREGATED;
    case 2:
    case "RATE_LIMITER_COUNTERS_MODE_DETAILED":
      return RateLimiterCountersMode.RATE_LIMITER_COUNTERS_MODE_DETAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RateLimiterCountersMode.UNRECOGNIZED;
  }
}

export function rateLimiterCountersModeToJSON(object: RateLimiterCountersMode): string {
  switch (object) {
    case RateLimiterCountersMode.RATE_LIMITER_COUNTERS_MODE_UNSET:
      return "RATE_LIMITER_COUNTERS_MODE_UNSET";
    case RateLimiterCountersMode.RATE_LIMITER_COUNTERS_MODE_AGGREGATED:
      return "RATE_LIMITER_COUNTERS_MODE_AGGREGATED";
    case RateLimiterCountersMode.RATE_LIMITER_COUNTERS_MODE_DETAILED:
      return "RATE_LIMITER_COUNTERS_MODE_DETAILED";
    case RateLimiterCountersMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Stub for unsupported messages */
export interface Unsupported {
}

/** Configuration settings for a coordination node */
export interface Config {
  /** Initialized on creation, cannot be set */
  path: string;
  /** Period in milliseconds for self-checks (default 1 second) */
  selfCheckPeriodMillis: number;
  /** Grace period for sessions on leader change (default 10 seconds) */
  sessionGracePeriodMillis: number;
  /** Concistency mode for read operations */
  readConsistencyMode: ConsistencyMode;
  /** Consistency mode for attach operations */
  attachConsistencyMode: ConsistencyMode;
  /** Rate limiter counters mode */
  rateLimiterCountersMode: RateLimiterCountersMode;
}

/** Describes an active client session */
export interface SessionDescription {
  /** Session id generated by the server */
  sessionId: number;
  /** Expiration timeout of the session */
  timeoutMillis: number;
  /** User-specified description of this session */
  description: string;
  /** True if this session is currently attached to a client */
  attached: boolean;
}

/** Describes an owner or a waiter of this semaphore */
export interface SemaphoreSession {
  /** A monotonically increasing id which determines locking order */
  orderId: number;
  /** An id of the session which tried to acquire the semaphore */
  sessionId: number;
  /** A timeout in milliseconds for operation in waiters queue */
  timeoutMillis: number;
  /** Number of tokens for an acquire operation */
  count: number;
  /** User-defined data attached to the acquire operation */
  data: Uint8Array;
}

/** Describes the state of a semaphore */
export interface SemaphoreDescription {
  /** Name of the semaphore */
  name: string;
  /** User-defined data attached to the semaphore */
  data: Uint8Array;
  /** Number of tokens currently acquired by owners */
  count: number;
  /** Maximum number of tokens that may acquired */
  limit: number;
  /** Ephemeral semaphores are deleted when released by all owners and waiters */
  ephemeral: boolean;
  /** A list of current owners of the semaphore */
  owners: SemaphoreSession[];
  /** A list of current waiters on the semaphore */
  waiters: SemaphoreSession[];
}

/** Session request message sent from client to server */
export interface SessionRequest {
  ping?: SessionRequest_PingPong | undefined;
  pong?: SessionRequest_PingPong | undefined;
  sessionStart?: SessionRequest_SessionStart | undefined;
  sessionStop?: SessionRequest_SessionStop | undefined;
  unsupported5?: Unsupported | undefined;
  unsupported6?: Unsupported | undefined;
  acquireSemaphore?: SessionRequest_AcquireSemaphore | undefined;
  releaseSemaphore?: SessionRequest_ReleaseSemaphore | undefined;
  describeSemaphore?: SessionRequest_DescribeSemaphore | undefined;
  createSemaphore?: SessionRequest_CreateSemaphore | undefined;
  updateSemaphore?: SessionRequest_UpdateSemaphore | undefined;
  deleteSemaphore?: SessionRequest_DeleteSemaphore | undefined;
  unsupported13?: Unsupported | undefined;
  unsupported14?: Unsupported | undefined;
  unsupported15?: Unsupported | undefined;
}

/** Used for checking liveness of the connection */
export interface SessionRequest_PingPong {
  /** Opaque number specified in the ping message is echoed in the pong message */
  opaque: number;
}

/** First message used to start/restore a session */
export interface SessionRequest_SessionStart {
  /** Path to a coordination node */
  path: string;
  /** Non-zero when restoring a session, 0 when creating a new session */
  sessionId: number;
  /** Timeout in milliseconds during which client may restore a detached session */
  timeoutMillis: number;
  /** User-defined description that may be used to describe the client */
  description: string;
  /**
   * Monotonically increasing sequence number generated by the client
   * When concurrent SessionStart requests are detected the one with
   * the biggest sequence number will succeed
   */
  seqNo: number;
  /** Random bytes used to protect session from restore by other clients (max. 16 bytes) */
  protectionKey: Uint8Array;
}

/** Last message used to cleanly stop session before its timeout expires */
export interface SessionRequest_SessionStop {
}

/**
 * Used to acquire a semaphore
 *
 * WARNING: a single session cannot acquire the same semaphore multiple times
 *
 * Later requests override previous operations with the same semaphore,
 * e.g. to reduce acquired count, change timeout or attached data.
 */
export interface SessionRequest_AcquireSemaphore {
  /** Client-defined request id, echoed in the response */
  reqId: number;
  /** Name of the semaphore to acquire */
  name: string;
  /**
   * Timeout in milliseconds after which operation will fail
   * if it's still waiting in the waiters queue
   */
  timeoutMillis: number;
  /** Number of tokens to acquire on the semaphore */
  count: number;
  /** User-defined binary data that may be attached to the operation */
  data: Uint8Array;
  /**
   * Ephemeral semaphores are created with the first acquire operation
   * and automatically deleted with the last release operation
   */
  ephemeral: boolean;
}

/**
 * Used to release a semaphore
 *
 * WARNING: a single session cannot release the same semaphore multiple times
 *
 * The release operation will either remove current session from waiters
 * queue or release an already owned semaphore.
 */
export interface SessionRequest_ReleaseSemaphore {
  /** Client-defined request id, echoed in the response */
  reqId: number;
  /** Name of the semaphore to release */
  name: string;
}

/**
 * Used to describe semaphores and watch them for changes
 *
 * WARNING: a describe operation will cancel previous watches on the same semaphore
 */
export interface SessionRequest_DescribeSemaphore {
  /** Client-defined request id, echoed in the response */
  reqId: number;
  /** Name of the semaphore to describe */
  name: string;
  /** Response will include owners list if true */
  includeOwners: boolean;
  /** Response will include waiters list if true */
  includeWaiters: boolean;
  /** Watch for changes in semaphore data */
  watchData: boolean;
  /** Watch for changes in semaphore owners (including owners data) */
  watchOwners: boolean;
}

/** Used to create a new semaphore */
export interface SessionRequest_CreateSemaphore {
  /** Client-defined request id, echoed in the response */
  reqId: number;
  /** Name of the semaphore to create */
  name: string;
  /** Number of tokens that may be acquired by sessions */
  limit: number;
  /** User-defined data that is attached to the semaphore */
  data: Uint8Array;
}

/** Used to change semaphore data */
export interface SessionRequest_UpdateSemaphore {
  /** Client-defined request id, echoed in the response */
  reqId: number;
  /** Name of the semaphore to update */
  name: string;
  /** User-defined data that is attached to the semaphore */
  data: Uint8Array;
}

/** Used to delete an existing semaphore */
export interface SessionRequest_DeleteSemaphore {
  /** Client-defined request id, echoed in the response */
  reqId: number;
  /** Name of the semaphore to delete */
  name: string;
  /** Will delete semaphore even if currently acquired by sessions */
  force: boolean;
}

/** Session response message sent from server to client */
export interface SessionResponse {
  ping?: SessionResponse_PingPong | undefined;
  pong?: SessionResponse_PingPong | undefined;
  failure?: SessionResponse_Failure | undefined;
  sessionStarted?: SessionResponse_SessionStarted | undefined;
  sessionStopped?: SessionResponse_SessionStopped | undefined;
  unsupported6?: Unsupported | undefined;
  unsupported7?: Unsupported | undefined;
  acquireSemaphorePending?: SessionResponse_AcquireSemaphorePending | undefined;
  acquireSemaphoreResult?: SessionResponse_AcquireSemaphoreResult | undefined;
  releaseSemaphoreResult?: SessionResponse_ReleaseSemaphoreResult | undefined;
  describeSemaphoreResult?: SessionResponse_DescribeSemaphoreResult | undefined;
  describeSemaphoreChanged?: SessionResponse_DescribeSemaphoreChanged | undefined;
  createSemaphoreResult?: SessionResponse_CreateSemaphoreResult | undefined;
  updateSemaphoreResult?: SessionResponse_UpdateSemaphoreResult | undefined;
  deleteSemaphoreResult?: SessionResponse_DeleteSemaphoreResult | undefined;
  unsupported16?: Unsupported | undefined;
  unsupported17?: Unsupported | undefined;
  unsupported18?: Unsupported | undefined;
}

/** Used for checking liveness of the connection */
export interface SessionResponse_PingPong {
  /** Opaque number specified in the ping message is echoed in the pong message */
  opaque: number;
}

/** Used to report connection and session level failures */
export interface SessionResponse_Failure {
  status: StatusIds_StatusCode;
  issues: IssueMessage[];
}

/** Used to report a successful session create/restore operation */
export interface SessionResponse_SessionStarted {
  /** A server generation id that may be used for restoring the session */
  sessionId: number;
  /** Timeout in milliseconds that will be used by the server */
  timeoutMillis: number;
}

/** Used to report a successful graceful termination of the session */
export interface SessionResponse_SessionStopped {
  sessionId: number;
}

/** Used by the server to report when an acquire operation is added to the waiters queue */
export interface SessionResponse_AcquireSemaphorePending {
  reqId: number;
}

/** Used by the server to report the result of an acquire operation */
export interface SessionResponse_AcquireSemaphoreResult {
  reqId: number;
  status: StatusIds_StatusCode;
  issues: IssueMessage[];
  /** True if semaphore was acquired, false if acquire timed out */
  acquired: boolean;
}

/** Used by the server to report the result of a release operation */
export interface SessionResponse_ReleaseSemaphoreResult {
  reqId: number;
  status: StatusIds_StatusCode;
  issues: IssueMessage[];
  /** True if semaphore was released, false if there was no active acquire operation */
  released: boolean;
}

/** The result of the describe operation */
export interface SessionResponse_DescribeSemaphoreResult {
  reqId: number;
  status: StatusIds_StatusCode;
  issues: IssueMessage[];
  semaphoreDescription:
    | SemaphoreDescription
    | undefined;
  /** True if a watch has been added for the semaphore */
  watchAdded: boolean;
}

/** Used to report a change in the watched semaphore */
export interface SessionResponse_DescribeSemaphoreChanged {
  reqId: number;
  dataChanged: boolean;
  ownersChanged: boolean;
}

/** The result of semaphore creation */
export interface SessionResponse_CreateSemaphoreResult {
  reqId: number;
  status: StatusIds_StatusCode;
  issues: IssueMessage[];
}

/** The result of semaphore update */
export interface SessionResponse_UpdateSemaphoreResult {
  reqId: number;
  status: StatusIds_StatusCode;
  issues: IssueMessage[];
}

/** The result of semaphore deletion */
export interface SessionResponse_DeleteSemaphoreResult {
  reqId: number;
  status: StatusIds_StatusCode;
  issues: IssueMessage[];
}

export interface CreateNodeRequest {
  path: string;
  config: Config | undefined;
  operationParams: OperationParams | undefined;
}

export interface CreateNodeResponse {
  operation: Operation | undefined;
}

export interface AlterNodeRequest {
  path: string;
  config: Config | undefined;
  operationParams: OperationParams | undefined;
}

export interface AlterNodeResponse {
  operation: Operation | undefined;
}

export interface DropNodeRequest {
  path: string;
  operationParams: OperationParams | undefined;
}

export interface DropNodeResponse {
  operation: Operation | undefined;
}

export interface DescribeNodeRequest {
  path: string;
  operationParams: OperationParams | undefined;
}

export interface DescribeNodeResponse {
  operation: Operation | undefined;
}

export interface DescribeNodeResult {
  self: Entry | undefined;
  config: Config | undefined;
}

function createBaseUnsupported(): Unsupported {
  return {};
}

export const Unsupported = {
  encode(_: Unsupported, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Unsupported {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnsupported();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Unsupported {
    return {};
  },

  toJSON(_: Unsupported): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Unsupported>, I>>(base?: I): Unsupported {
    return Unsupported.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Unsupported>, I>>(_: I): Unsupported {
    const message = createBaseUnsupported();
    return message;
  },
};

function createBaseConfig(): Config {
  return {
    path: "",
    selfCheckPeriodMillis: 0,
    sessionGracePeriodMillis: 0,
    readConsistencyMode: 0,
    attachConsistencyMode: 0,
    rateLimiterCountersMode: 0,
  };
}

export const Config = {
  encode(message: Config, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.selfCheckPeriodMillis !== 0) {
      writer.uint32(16).uint32(message.selfCheckPeriodMillis);
    }
    if (message.sessionGracePeriodMillis !== 0) {
      writer.uint32(24).uint32(message.sessionGracePeriodMillis);
    }
    if (message.readConsistencyMode !== 0) {
      writer.uint32(32).int32(message.readConsistencyMode);
    }
    if (message.attachConsistencyMode !== 0) {
      writer.uint32(40).int32(message.attachConsistencyMode);
    }
    if (message.rateLimiterCountersMode !== 0) {
      writer.uint32(48).int32(message.rateLimiterCountersMode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Config {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.selfCheckPeriodMillis = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sessionGracePeriodMillis = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.readConsistencyMode = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.attachConsistencyMode = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.rateLimiterCountersMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Config {
    return {
      path: isSet(object.path) ? String(object.path) : "",
      selfCheckPeriodMillis: isSet(object.selfCheckPeriodMillis) ? Number(object.selfCheckPeriodMillis) : 0,
      sessionGracePeriodMillis: isSet(object.sessionGracePeriodMillis) ? Number(object.sessionGracePeriodMillis) : 0,
      readConsistencyMode: isSet(object.readConsistencyMode) ? consistencyModeFromJSON(object.readConsistencyMode) : 0,
      attachConsistencyMode: isSet(object.attachConsistencyMode)
        ? consistencyModeFromJSON(object.attachConsistencyMode)
        : 0,
      rateLimiterCountersMode: isSet(object.rateLimiterCountersMode)
        ? rateLimiterCountersModeFromJSON(object.rateLimiterCountersMode)
        : 0,
    };
  },

  toJSON(message: Config): unknown {
    const obj: any = {};
    message.path !== undefined && (obj.path = message.path);
    message.selfCheckPeriodMillis !== undefined &&
      (obj.selfCheckPeriodMillis = Math.round(message.selfCheckPeriodMillis));
    message.sessionGracePeriodMillis !== undefined &&
      (obj.sessionGracePeriodMillis = Math.round(message.sessionGracePeriodMillis));
    message.readConsistencyMode !== undefined &&
      (obj.readConsistencyMode = consistencyModeToJSON(message.readConsistencyMode));
    message.attachConsistencyMode !== undefined &&
      (obj.attachConsistencyMode = consistencyModeToJSON(message.attachConsistencyMode));
    message.rateLimiterCountersMode !== undefined &&
      (obj.rateLimiterCountersMode = rateLimiterCountersModeToJSON(message.rateLimiterCountersMode));
    return obj;
  },

  create<I extends Exact<DeepPartial<Config>, I>>(base?: I): Config {
    return Config.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<Config>, I>>(object: I): Config {
    const message = createBaseConfig();
    message.path = object.path ?? "";
    message.selfCheckPeriodMillis = object.selfCheckPeriodMillis ?? 0;
    message.sessionGracePeriodMillis = object.sessionGracePeriodMillis ?? 0;
    message.readConsistencyMode = object.readConsistencyMode ?? 0;
    message.attachConsistencyMode = object.attachConsistencyMode ?? 0;
    message.rateLimiterCountersMode = object.rateLimiterCountersMode ?? 0;
    return message;
  },
};

function createBaseSessionDescription(): SessionDescription {
  return { sessionId: 0, timeoutMillis: 0, description: "", attached: false };
}

export const SessionDescription = {
  encode(message: SessionDescription, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).uint64(message.sessionId);
    }
    if (message.timeoutMillis !== 0) {
      writer.uint32(16).uint64(message.timeoutMillis);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.attached === true) {
      writer.uint32(32).bool(message.attached);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionDescription {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timeoutMillis = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.attached = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionDescription {
    return {
      sessionId: isSet(object.sessionId) ? Number(object.sessionId) : 0,
      timeoutMillis: isSet(object.timeoutMillis) ? Number(object.timeoutMillis) : 0,
      description: isSet(object.description) ? String(object.description) : "",
      attached: isSet(object.attached) ? Boolean(object.attached) : false,
    };
  },

  toJSON(message: SessionDescription): unknown {
    const obj: any = {};
    message.sessionId !== undefined && (obj.sessionId = Math.round(message.sessionId));
    message.timeoutMillis !== undefined && (obj.timeoutMillis = Math.round(message.timeoutMillis));
    message.description !== undefined && (obj.description = message.description);
    message.attached !== undefined && (obj.attached = message.attached);
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionDescription>, I>>(base?: I): SessionDescription {
    return SessionDescription.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionDescription>, I>>(object: I): SessionDescription {
    const message = createBaseSessionDescription();
    message.sessionId = object.sessionId ?? 0;
    message.timeoutMillis = object.timeoutMillis ?? 0;
    message.description = object.description ?? "";
    message.attached = object.attached ?? false;
    return message;
  },
};

function createBaseSemaphoreSession(): SemaphoreSession {
  return { orderId: 0, sessionId: 0, timeoutMillis: 0, count: 0, data: new Uint8Array() };
}

export const SemaphoreSession = {
  encode(message: SemaphoreSession, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderId !== 0) {
      writer.uint32(40).uint64(message.orderId);
    }
    if (message.sessionId !== 0) {
      writer.uint32(8).uint64(message.sessionId);
    }
    if (message.timeoutMillis !== 0) {
      writer.uint32(16).uint64(message.timeoutMillis);
    }
    if (message.count !== 0) {
      writer.uint32(24).uint64(message.count);
    }
    if (message.data.length !== 0) {
      writer.uint32(34).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SemaphoreSession {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSemaphoreSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 40) {
            break;
          }

          message.orderId = longToNumber(reader.uint64() as Long);
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timeoutMillis = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.count = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.data = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SemaphoreSession {
    return {
      orderId: isSet(object.orderId) ? Number(object.orderId) : 0,
      sessionId: isSet(object.sessionId) ? Number(object.sessionId) : 0,
      timeoutMillis: isSet(object.timeoutMillis) ? Number(object.timeoutMillis) : 0,
      count: isSet(object.count) ? Number(object.count) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
    };
  },

  toJSON(message: SemaphoreSession): unknown {
    const obj: any = {};
    message.orderId !== undefined && (obj.orderId = Math.round(message.orderId));
    message.sessionId !== undefined && (obj.sessionId = Math.round(message.sessionId));
    message.timeoutMillis !== undefined && (obj.timeoutMillis = Math.round(message.timeoutMillis));
    message.count !== undefined && (obj.count = Math.round(message.count));
    message.data !== undefined &&
      (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
    return obj;
  },

  create<I extends Exact<DeepPartial<SemaphoreSession>, I>>(base?: I): SemaphoreSession {
    return SemaphoreSession.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SemaphoreSession>, I>>(object: I): SemaphoreSession {
    const message = createBaseSemaphoreSession();
    message.orderId = object.orderId ?? 0;
    message.sessionId = object.sessionId ?? 0;
    message.timeoutMillis = object.timeoutMillis ?? 0;
    message.count = object.count ?? 0;
    message.data = object.data ?? new Uint8Array();
    return message;
  },
};

function createBaseSemaphoreDescription(): SemaphoreDescription {
  return { name: "", data: new Uint8Array(), count: 0, limit: 0, ephemeral: false, owners: [], waiters: [] };
}

export const SemaphoreDescription = {
  encode(message: SemaphoreDescription, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.count !== 0) {
      writer.uint32(56).uint64(message.count);
    }
    if (message.limit !== 0) {
      writer.uint32(24).uint64(message.limit);
    }
    if (message.ephemeral === true) {
      writer.uint32(32).bool(message.ephemeral);
    }
    for (const v of message.owners) {
      SemaphoreSession.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.waiters) {
      SemaphoreSession.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SemaphoreDescription {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSemaphoreDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.count = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.ephemeral = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.owners.push(SemaphoreSession.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.waiters.push(SemaphoreSession.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SemaphoreDescription {
    return {
      name: isSet(object.name) ? String(object.name) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
      count: isSet(object.count) ? Number(object.count) : 0,
      limit: isSet(object.limit) ? Number(object.limit) : 0,
      ephemeral: isSet(object.ephemeral) ? Boolean(object.ephemeral) : false,
      owners: Array.isArray(object?.owners) ? object.owners.map((e: any) => SemaphoreSession.fromJSON(e)) : [],
      waiters: Array.isArray(object?.waiters) ? object.waiters.map((e: any) => SemaphoreSession.fromJSON(e)) : [],
    };
  },

  toJSON(message: SemaphoreDescription): unknown {
    const obj: any = {};
    message.name !== undefined && (obj.name = message.name);
    message.data !== undefined &&
      (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
    message.count !== undefined && (obj.count = Math.round(message.count));
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    message.ephemeral !== undefined && (obj.ephemeral = message.ephemeral);
    if (message.owners) {
      obj.owners = message.owners.map((e) => e ? SemaphoreSession.toJSON(e) : undefined);
    } else {
      obj.owners = [];
    }
    if (message.waiters) {
      obj.waiters = message.waiters.map((e) => e ? SemaphoreSession.toJSON(e) : undefined);
    } else {
      obj.waiters = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SemaphoreDescription>, I>>(base?: I): SemaphoreDescription {
    return SemaphoreDescription.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SemaphoreDescription>, I>>(object: I): SemaphoreDescription {
    const message = createBaseSemaphoreDescription();
    message.name = object.name ?? "";
    message.data = object.data ?? new Uint8Array();
    message.count = object.count ?? 0;
    message.limit = object.limit ?? 0;
    message.ephemeral = object.ephemeral ?? false;
    message.owners = object.owners?.map((e) => SemaphoreSession.fromPartial(e)) || [];
    message.waiters = object.waiters?.map((e) => SemaphoreSession.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSessionRequest(): SessionRequest {
  return {
    ping: undefined,
    pong: undefined,
    sessionStart: undefined,
    sessionStop: undefined,
    unsupported5: undefined,
    unsupported6: undefined,
    acquireSemaphore: undefined,
    releaseSemaphore: undefined,
    describeSemaphore: undefined,
    createSemaphore: undefined,
    updateSemaphore: undefined,
    deleteSemaphore: undefined,
    unsupported13: undefined,
    unsupported14: undefined,
    unsupported15: undefined,
  };
}

export const SessionRequest = {
  encode(message: SessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ping !== undefined) {
      SessionRequest_PingPong.encode(message.ping, writer.uint32(10).fork()).ldelim();
    }
    if (message.pong !== undefined) {
      SessionRequest_PingPong.encode(message.pong, writer.uint32(18).fork()).ldelim();
    }
    if (message.sessionStart !== undefined) {
      SessionRequest_SessionStart.encode(message.sessionStart, writer.uint32(26).fork()).ldelim();
    }
    if (message.sessionStop !== undefined) {
      SessionRequest_SessionStop.encode(message.sessionStop, writer.uint32(34).fork()).ldelim();
    }
    if (message.unsupported5 !== undefined) {
      Unsupported.encode(message.unsupported5, writer.uint32(42).fork()).ldelim();
    }
    if (message.unsupported6 !== undefined) {
      Unsupported.encode(message.unsupported6, writer.uint32(50).fork()).ldelim();
    }
    if (message.acquireSemaphore !== undefined) {
      SessionRequest_AcquireSemaphore.encode(message.acquireSemaphore, writer.uint32(58).fork()).ldelim();
    }
    if (message.releaseSemaphore !== undefined) {
      SessionRequest_ReleaseSemaphore.encode(message.releaseSemaphore, writer.uint32(66).fork()).ldelim();
    }
    if (message.describeSemaphore !== undefined) {
      SessionRequest_DescribeSemaphore.encode(message.describeSemaphore, writer.uint32(74).fork()).ldelim();
    }
    if (message.createSemaphore !== undefined) {
      SessionRequest_CreateSemaphore.encode(message.createSemaphore, writer.uint32(82).fork()).ldelim();
    }
    if (message.updateSemaphore !== undefined) {
      SessionRequest_UpdateSemaphore.encode(message.updateSemaphore, writer.uint32(90).fork()).ldelim();
    }
    if (message.deleteSemaphore !== undefined) {
      SessionRequest_DeleteSemaphore.encode(message.deleteSemaphore, writer.uint32(98).fork()).ldelim();
    }
    if (message.unsupported13 !== undefined) {
      Unsupported.encode(message.unsupported13, writer.uint32(106).fork()).ldelim();
    }
    if (message.unsupported14 !== undefined) {
      Unsupported.encode(message.unsupported14, writer.uint32(114).fork()).ldelim();
    }
    if (message.unsupported15 !== undefined) {
      Unsupported.encode(message.unsupported15, writer.uint32(122).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ping = SessionRequest_PingPong.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pong = SessionRequest_PingPong.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sessionStart = SessionRequest_SessionStart.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sessionStop = SessionRequest_SessionStop.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.unsupported5 = Unsupported.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.unsupported6 = Unsupported.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.acquireSemaphore = SessionRequest_AcquireSemaphore.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.releaseSemaphore = SessionRequest_ReleaseSemaphore.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.describeSemaphore = SessionRequest_DescribeSemaphore.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.createSemaphore = SessionRequest_CreateSemaphore.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updateSemaphore = SessionRequest_UpdateSemaphore.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.deleteSemaphore = SessionRequest_DeleteSemaphore.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.unsupported13 = Unsupported.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.unsupported14 = Unsupported.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.unsupported15 = Unsupported.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionRequest {
    return {
      ping: isSet(object.ping) ? SessionRequest_PingPong.fromJSON(object.ping) : undefined,
      pong: isSet(object.pong) ? SessionRequest_PingPong.fromJSON(object.pong) : undefined,
      sessionStart: isSet(object.sessionStart) ? SessionRequest_SessionStart.fromJSON(object.sessionStart) : undefined,
      sessionStop: isSet(object.sessionStop) ? SessionRequest_SessionStop.fromJSON(object.sessionStop) : undefined,
      unsupported5: isSet(object.unsupported5) ? Unsupported.fromJSON(object.unsupported5) : undefined,
      unsupported6: isSet(object.unsupported6) ? Unsupported.fromJSON(object.unsupported6) : undefined,
      acquireSemaphore: isSet(object.acquireSemaphore)
        ? SessionRequest_AcquireSemaphore.fromJSON(object.acquireSemaphore)
        : undefined,
      releaseSemaphore: isSet(object.releaseSemaphore)
        ? SessionRequest_ReleaseSemaphore.fromJSON(object.releaseSemaphore)
        : undefined,
      describeSemaphore: isSet(object.describeSemaphore)
        ? SessionRequest_DescribeSemaphore.fromJSON(object.describeSemaphore)
        : undefined,
      createSemaphore: isSet(object.createSemaphore)
        ? SessionRequest_CreateSemaphore.fromJSON(object.createSemaphore)
        : undefined,
      updateSemaphore: isSet(object.updateSemaphore)
        ? SessionRequest_UpdateSemaphore.fromJSON(object.updateSemaphore)
        : undefined,
      deleteSemaphore: isSet(object.deleteSemaphore)
        ? SessionRequest_DeleteSemaphore.fromJSON(object.deleteSemaphore)
        : undefined,
      unsupported13: isSet(object.unsupported13) ? Unsupported.fromJSON(object.unsupported13) : undefined,
      unsupported14: isSet(object.unsupported14) ? Unsupported.fromJSON(object.unsupported14) : undefined,
      unsupported15: isSet(object.unsupported15) ? Unsupported.fromJSON(object.unsupported15) : undefined,
    };
  },

  toJSON(message: SessionRequest): unknown {
    const obj: any = {};
    message.ping !== undefined && (obj.ping = message.ping ? SessionRequest_PingPong.toJSON(message.ping) : undefined);
    message.pong !== undefined && (obj.pong = message.pong ? SessionRequest_PingPong.toJSON(message.pong) : undefined);
    message.sessionStart !== undefined &&
      (obj.sessionStart = message.sessionStart ? SessionRequest_SessionStart.toJSON(message.sessionStart) : undefined);
    message.sessionStop !== undefined &&
      (obj.sessionStop = message.sessionStop ? SessionRequest_SessionStop.toJSON(message.sessionStop) : undefined);
    message.unsupported5 !== undefined &&
      (obj.unsupported5 = message.unsupported5 ? Unsupported.toJSON(message.unsupported5) : undefined);
    message.unsupported6 !== undefined &&
      (obj.unsupported6 = message.unsupported6 ? Unsupported.toJSON(message.unsupported6) : undefined);
    message.acquireSemaphore !== undefined && (obj.acquireSemaphore = message.acquireSemaphore
      ? SessionRequest_AcquireSemaphore.toJSON(message.acquireSemaphore)
      : undefined);
    message.releaseSemaphore !== undefined && (obj.releaseSemaphore = message.releaseSemaphore
      ? SessionRequest_ReleaseSemaphore.toJSON(message.releaseSemaphore)
      : undefined);
    message.describeSemaphore !== undefined && (obj.describeSemaphore = message.describeSemaphore
      ? SessionRequest_DescribeSemaphore.toJSON(message.describeSemaphore)
      : undefined);
    message.createSemaphore !== undefined && (obj.createSemaphore = message.createSemaphore
      ? SessionRequest_CreateSemaphore.toJSON(message.createSemaphore)
      : undefined);
    message.updateSemaphore !== undefined && (obj.updateSemaphore = message.updateSemaphore
      ? SessionRequest_UpdateSemaphore.toJSON(message.updateSemaphore)
      : undefined);
    message.deleteSemaphore !== undefined && (obj.deleteSemaphore = message.deleteSemaphore
      ? SessionRequest_DeleteSemaphore.toJSON(message.deleteSemaphore)
      : undefined);
    message.unsupported13 !== undefined &&
      (obj.unsupported13 = message.unsupported13 ? Unsupported.toJSON(message.unsupported13) : undefined);
    message.unsupported14 !== undefined &&
      (obj.unsupported14 = message.unsupported14 ? Unsupported.toJSON(message.unsupported14) : undefined);
    message.unsupported15 !== undefined &&
      (obj.unsupported15 = message.unsupported15 ? Unsupported.toJSON(message.unsupported15) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionRequest>, I>>(base?: I): SessionRequest {
    return SessionRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionRequest>, I>>(object: I): SessionRequest {
    const message = createBaseSessionRequest();
    message.ping = (object.ping !== undefined && object.ping !== null)
      ? SessionRequest_PingPong.fromPartial(object.ping)
      : undefined;
    message.pong = (object.pong !== undefined && object.pong !== null)
      ? SessionRequest_PingPong.fromPartial(object.pong)
      : undefined;
    message.sessionStart = (object.sessionStart !== undefined && object.sessionStart !== null)
      ? SessionRequest_SessionStart.fromPartial(object.sessionStart)
      : undefined;
    message.sessionStop = (object.sessionStop !== undefined && object.sessionStop !== null)
      ? SessionRequest_SessionStop.fromPartial(object.sessionStop)
      : undefined;
    message.unsupported5 = (object.unsupported5 !== undefined && object.unsupported5 !== null)
      ? Unsupported.fromPartial(object.unsupported5)
      : undefined;
    message.unsupported6 = (object.unsupported6 !== undefined && object.unsupported6 !== null)
      ? Unsupported.fromPartial(object.unsupported6)
      : undefined;
    message.acquireSemaphore = (object.acquireSemaphore !== undefined && object.acquireSemaphore !== null)
      ? SessionRequest_AcquireSemaphore.fromPartial(object.acquireSemaphore)
      : undefined;
    message.releaseSemaphore = (object.releaseSemaphore !== undefined && object.releaseSemaphore !== null)
      ? SessionRequest_ReleaseSemaphore.fromPartial(object.releaseSemaphore)
      : undefined;
    message.describeSemaphore = (object.describeSemaphore !== undefined && object.describeSemaphore !== null)
      ? SessionRequest_DescribeSemaphore.fromPartial(object.describeSemaphore)
      : undefined;
    message.createSemaphore = (object.createSemaphore !== undefined && object.createSemaphore !== null)
      ? SessionRequest_CreateSemaphore.fromPartial(object.createSemaphore)
      : undefined;
    message.updateSemaphore = (object.updateSemaphore !== undefined && object.updateSemaphore !== null)
      ? SessionRequest_UpdateSemaphore.fromPartial(object.updateSemaphore)
      : undefined;
    message.deleteSemaphore = (object.deleteSemaphore !== undefined && object.deleteSemaphore !== null)
      ? SessionRequest_DeleteSemaphore.fromPartial(object.deleteSemaphore)
      : undefined;
    message.unsupported13 = (object.unsupported13 !== undefined && object.unsupported13 !== null)
      ? Unsupported.fromPartial(object.unsupported13)
      : undefined;
    message.unsupported14 = (object.unsupported14 !== undefined && object.unsupported14 !== null)
      ? Unsupported.fromPartial(object.unsupported14)
      : undefined;
    message.unsupported15 = (object.unsupported15 !== undefined && object.unsupported15 !== null)
      ? Unsupported.fromPartial(object.unsupported15)
      : undefined;
    return message;
  },
};

function createBaseSessionRequest_PingPong(): SessionRequest_PingPong {
  return { opaque: 0 };
}

export const SessionRequest_PingPong = {
  encode(message: SessionRequest_PingPong, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.opaque !== 0) {
      writer.uint32(8).uint64(message.opaque);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionRequest_PingPong {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionRequest_PingPong();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.opaque = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionRequest_PingPong {
    return { opaque: isSet(object.opaque) ? Number(object.opaque) : 0 };
  },

  toJSON(message: SessionRequest_PingPong): unknown {
    const obj: any = {};
    message.opaque !== undefined && (obj.opaque = Math.round(message.opaque));
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionRequest_PingPong>, I>>(base?: I): SessionRequest_PingPong {
    return SessionRequest_PingPong.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionRequest_PingPong>, I>>(object: I): SessionRequest_PingPong {
    const message = createBaseSessionRequest_PingPong();
    message.opaque = object.opaque ?? 0;
    return message;
  },
};

function createBaseSessionRequest_SessionStart(): SessionRequest_SessionStart {
  return { path: "", sessionId: 0, timeoutMillis: 0, description: "", seqNo: 0, protectionKey: new Uint8Array() };
}

export const SessionRequest_SessionStart = {
  encode(message: SessionRequest_SessionStart, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.sessionId !== 0) {
      writer.uint32(16).uint64(message.sessionId);
    }
    if (message.timeoutMillis !== 0) {
      writer.uint32(24).uint64(message.timeoutMillis);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.seqNo !== 0) {
      writer.uint32(40).uint64(message.seqNo);
    }
    if (message.protectionKey.length !== 0) {
      writer.uint32(50).bytes(message.protectionKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionRequest_SessionStart {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionRequest_SessionStart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sessionId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timeoutMillis = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.seqNo = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.protectionKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionRequest_SessionStart {
    return {
      path: isSet(object.path) ? String(object.path) : "",
      sessionId: isSet(object.sessionId) ? Number(object.sessionId) : 0,
      timeoutMillis: isSet(object.timeoutMillis) ? Number(object.timeoutMillis) : 0,
      description: isSet(object.description) ? String(object.description) : "",
      seqNo: isSet(object.seqNo) ? Number(object.seqNo) : 0,
      protectionKey: isSet(object.protectionKey) ? bytesFromBase64(object.protectionKey) : new Uint8Array(),
    };
  },

  toJSON(message: SessionRequest_SessionStart): unknown {
    const obj: any = {};
    message.path !== undefined && (obj.path = message.path);
    message.sessionId !== undefined && (obj.sessionId = Math.round(message.sessionId));
    message.timeoutMillis !== undefined && (obj.timeoutMillis = Math.round(message.timeoutMillis));
    message.description !== undefined && (obj.description = message.description);
    message.seqNo !== undefined && (obj.seqNo = Math.round(message.seqNo));
    message.protectionKey !== undefined &&
      (obj.protectionKey = base64FromBytes(
        message.protectionKey !== undefined ? message.protectionKey : new Uint8Array(),
      ));
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionRequest_SessionStart>, I>>(base?: I): SessionRequest_SessionStart {
    return SessionRequest_SessionStart.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionRequest_SessionStart>, I>>(object: I): SessionRequest_SessionStart {
    const message = createBaseSessionRequest_SessionStart();
    message.path = object.path ?? "";
    message.sessionId = object.sessionId ?? 0;
    message.timeoutMillis = object.timeoutMillis ?? 0;
    message.description = object.description ?? "";
    message.seqNo = object.seqNo ?? 0;
    message.protectionKey = object.protectionKey ?? new Uint8Array();
    return message;
  },
};

function createBaseSessionRequest_SessionStop(): SessionRequest_SessionStop {
  return {};
}

export const SessionRequest_SessionStop = {
  encode(_: SessionRequest_SessionStop, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionRequest_SessionStop {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionRequest_SessionStop();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SessionRequest_SessionStop {
    return {};
  },

  toJSON(_: SessionRequest_SessionStop): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionRequest_SessionStop>, I>>(base?: I): SessionRequest_SessionStop {
    return SessionRequest_SessionStop.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionRequest_SessionStop>, I>>(_: I): SessionRequest_SessionStop {
    const message = createBaseSessionRequest_SessionStop();
    return message;
  },
};

function createBaseSessionRequest_AcquireSemaphore(): SessionRequest_AcquireSemaphore {
  return { reqId: 0, name: "", timeoutMillis: 0, count: 0, data: new Uint8Array(), ephemeral: false };
}

export const SessionRequest_AcquireSemaphore = {
  encode(message: SessionRequest_AcquireSemaphore, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reqId !== 0) {
      writer.uint32(8).uint64(message.reqId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.timeoutMillis !== 0) {
      writer.uint32(24).uint64(message.timeoutMillis);
    }
    if (message.count !== 0) {
      writer.uint32(32).uint64(message.count);
    }
    if (message.data.length !== 0) {
      writer.uint32(42).bytes(message.data);
    }
    if (message.ephemeral === true) {
      writer.uint32(48).bool(message.ephemeral);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionRequest_AcquireSemaphore {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionRequest_AcquireSemaphore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reqId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timeoutMillis = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.count = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.ephemeral = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionRequest_AcquireSemaphore {
    return {
      reqId: isSet(object.reqId) ? Number(object.reqId) : 0,
      name: isSet(object.name) ? String(object.name) : "",
      timeoutMillis: isSet(object.timeoutMillis) ? Number(object.timeoutMillis) : 0,
      count: isSet(object.count) ? Number(object.count) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
      ephemeral: isSet(object.ephemeral) ? Boolean(object.ephemeral) : false,
    };
  },

  toJSON(message: SessionRequest_AcquireSemaphore): unknown {
    const obj: any = {};
    message.reqId !== undefined && (obj.reqId = Math.round(message.reqId));
    message.name !== undefined && (obj.name = message.name);
    message.timeoutMillis !== undefined && (obj.timeoutMillis = Math.round(message.timeoutMillis));
    message.count !== undefined && (obj.count = Math.round(message.count));
    message.data !== undefined &&
      (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
    message.ephemeral !== undefined && (obj.ephemeral = message.ephemeral);
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionRequest_AcquireSemaphore>, I>>(base?: I): SessionRequest_AcquireSemaphore {
    return SessionRequest_AcquireSemaphore.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionRequest_AcquireSemaphore>, I>>(
    object: I,
  ): SessionRequest_AcquireSemaphore {
    const message = createBaseSessionRequest_AcquireSemaphore();
    message.reqId = object.reqId ?? 0;
    message.name = object.name ?? "";
    message.timeoutMillis = object.timeoutMillis ?? 0;
    message.count = object.count ?? 0;
    message.data = object.data ?? new Uint8Array();
    message.ephemeral = object.ephemeral ?? false;
    return message;
  },
};

function createBaseSessionRequest_ReleaseSemaphore(): SessionRequest_ReleaseSemaphore {
  return { reqId: 0, name: "" };
}

export const SessionRequest_ReleaseSemaphore = {
  encode(message: SessionRequest_ReleaseSemaphore, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reqId !== 0) {
      writer.uint32(8).uint64(message.reqId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionRequest_ReleaseSemaphore {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionRequest_ReleaseSemaphore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reqId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionRequest_ReleaseSemaphore {
    return {
      reqId: isSet(object.reqId) ? Number(object.reqId) : 0,
      name: isSet(object.name) ? String(object.name) : "",
    };
  },

  toJSON(message: SessionRequest_ReleaseSemaphore): unknown {
    const obj: any = {};
    message.reqId !== undefined && (obj.reqId = Math.round(message.reqId));
    message.name !== undefined && (obj.name = message.name);
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionRequest_ReleaseSemaphore>, I>>(base?: I): SessionRequest_ReleaseSemaphore {
    return SessionRequest_ReleaseSemaphore.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionRequest_ReleaseSemaphore>, I>>(
    object: I,
  ): SessionRequest_ReleaseSemaphore {
    const message = createBaseSessionRequest_ReleaseSemaphore();
    message.reqId = object.reqId ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSessionRequest_DescribeSemaphore(): SessionRequest_DescribeSemaphore {
  return { reqId: 0, name: "", includeOwners: false, includeWaiters: false, watchData: false, watchOwners: false };
}

export const SessionRequest_DescribeSemaphore = {
  encode(message: SessionRequest_DescribeSemaphore, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reqId !== 0) {
      writer.uint32(8).uint64(message.reqId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.includeOwners === true) {
      writer.uint32(24).bool(message.includeOwners);
    }
    if (message.includeWaiters === true) {
      writer.uint32(32).bool(message.includeWaiters);
    }
    if (message.watchData === true) {
      writer.uint32(40).bool(message.watchData);
    }
    if (message.watchOwners === true) {
      writer.uint32(48).bool(message.watchOwners);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionRequest_DescribeSemaphore {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionRequest_DescribeSemaphore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reqId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.includeOwners = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.includeWaiters = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.watchData = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.watchOwners = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionRequest_DescribeSemaphore {
    return {
      reqId: isSet(object.reqId) ? Number(object.reqId) : 0,
      name: isSet(object.name) ? String(object.name) : "",
      includeOwners: isSet(object.includeOwners) ? Boolean(object.includeOwners) : false,
      includeWaiters: isSet(object.includeWaiters) ? Boolean(object.includeWaiters) : false,
      watchData: isSet(object.watchData) ? Boolean(object.watchData) : false,
      watchOwners: isSet(object.watchOwners) ? Boolean(object.watchOwners) : false,
    };
  },

  toJSON(message: SessionRequest_DescribeSemaphore): unknown {
    const obj: any = {};
    message.reqId !== undefined && (obj.reqId = Math.round(message.reqId));
    message.name !== undefined && (obj.name = message.name);
    message.includeOwners !== undefined && (obj.includeOwners = message.includeOwners);
    message.includeWaiters !== undefined && (obj.includeWaiters = message.includeWaiters);
    message.watchData !== undefined && (obj.watchData = message.watchData);
    message.watchOwners !== undefined && (obj.watchOwners = message.watchOwners);
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionRequest_DescribeSemaphore>, I>>(
    base?: I,
  ): SessionRequest_DescribeSemaphore {
    return SessionRequest_DescribeSemaphore.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionRequest_DescribeSemaphore>, I>>(
    object: I,
  ): SessionRequest_DescribeSemaphore {
    const message = createBaseSessionRequest_DescribeSemaphore();
    message.reqId = object.reqId ?? 0;
    message.name = object.name ?? "";
    message.includeOwners = object.includeOwners ?? false;
    message.includeWaiters = object.includeWaiters ?? false;
    message.watchData = object.watchData ?? false;
    message.watchOwners = object.watchOwners ?? false;
    return message;
  },
};

function createBaseSessionRequest_CreateSemaphore(): SessionRequest_CreateSemaphore {
  return { reqId: 0, name: "", limit: 0, data: new Uint8Array() };
}

export const SessionRequest_CreateSemaphore = {
  encode(message: SessionRequest_CreateSemaphore, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reqId !== 0) {
      writer.uint32(8).uint64(message.reqId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.limit !== 0) {
      writer.uint32(24).uint64(message.limit);
    }
    if (message.data.length !== 0) {
      writer.uint32(34).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionRequest_CreateSemaphore {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionRequest_CreateSemaphore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reqId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.data = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionRequest_CreateSemaphore {
    return {
      reqId: isSet(object.reqId) ? Number(object.reqId) : 0,
      name: isSet(object.name) ? String(object.name) : "",
      limit: isSet(object.limit) ? Number(object.limit) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
    };
  },

  toJSON(message: SessionRequest_CreateSemaphore): unknown {
    const obj: any = {};
    message.reqId !== undefined && (obj.reqId = Math.round(message.reqId));
    message.name !== undefined && (obj.name = message.name);
    message.limit !== undefined && (obj.limit = Math.round(message.limit));
    message.data !== undefined &&
      (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionRequest_CreateSemaphore>, I>>(base?: I): SessionRequest_CreateSemaphore {
    return SessionRequest_CreateSemaphore.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionRequest_CreateSemaphore>, I>>(
    object: I,
  ): SessionRequest_CreateSemaphore {
    const message = createBaseSessionRequest_CreateSemaphore();
    message.reqId = object.reqId ?? 0;
    message.name = object.name ?? "";
    message.limit = object.limit ?? 0;
    message.data = object.data ?? new Uint8Array();
    return message;
  },
};

function createBaseSessionRequest_UpdateSemaphore(): SessionRequest_UpdateSemaphore {
  return { reqId: 0, name: "", data: new Uint8Array() };
}

export const SessionRequest_UpdateSemaphore = {
  encode(message: SessionRequest_UpdateSemaphore, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reqId !== 0) {
      writer.uint32(8).uint64(message.reqId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionRequest_UpdateSemaphore {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionRequest_UpdateSemaphore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reqId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionRequest_UpdateSemaphore {
    return {
      reqId: isSet(object.reqId) ? Number(object.reqId) : 0,
      name: isSet(object.name) ? String(object.name) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
    };
  },

  toJSON(message: SessionRequest_UpdateSemaphore): unknown {
    const obj: any = {};
    message.reqId !== undefined && (obj.reqId = Math.round(message.reqId));
    message.name !== undefined && (obj.name = message.name);
    message.data !== undefined &&
      (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionRequest_UpdateSemaphore>, I>>(base?: I): SessionRequest_UpdateSemaphore {
    return SessionRequest_UpdateSemaphore.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionRequest_UpdateSemaphore>, I>>(
    object: I,
  ): SessionRequest_UpdateSemaphore {
    const message = createBaseSessionRequest_UpdateSemaphore();
    message.reqId = object.reqId ?? 0;
    message.name = object.name ?? "";
    message.data = object.data ?? new Uint8Array();
    return message;
  },
};

function createBaseSessionRequest_DeleteSemaphore(): SessionRequest_DeleteSemaphore {
  return { reqId: 0, name: "", force: false };
}

export const SessionRequest_DeleteSemaphore = {
  encode(message: SessionRequest_DeleteSemaphore, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reqId !== 0) {
      writer.uint32(8).uint64(message.reqId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.force === true) {
      writer.uint32(24).bool(message.force);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionRequest_DeleteSemaphore {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionRequest_DeleteSemaphore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reqId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionRequest_DeleteSemaphore {
    return {
      reqId: isSet(object.reqId) ? Number(object.reqId) : 0,
      name: isSet(object.name) ? String(object.name) : "",
      force: isSet(object.force) ? Boolean(object.force) : false,
    };
  },

  toJSON(message: SessionRequest_DeleteSemaphore): unknown {
    const obj: any = {};
    message.reqId !== undefined && (obj.reqId = Math.round(message.reqId));
    message.name !== undefined && (obj.name = message.name);
    message.force !== undefined && (obj.force = message.force);
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionRequest_DeleteSemaphore>, I>>(base?: I): SessionRequest_DeleteSemaphore {
    return SessionRequest_DeleteSemaphore.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionRequest_DeleteSemaphore>, I>>(
    object: I,
  ): SessionRequest_DeleteSemaphore {
    const message = createBaseSessionRequest_DeleteSemaphore();
    message.reqId = object.reqId ?? 0;
    message.name = object.name ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseSessionResponse(): SessionResponse {
  return {
    ping: undefined,
    pong: undefined,
    failure: undefined,
    sessionStarted: undefined,
    sessionStopped: undefined,
    unsupported6: undefined,
    unsupported7: undefined,
    acquireSemaphorePending: undefined,
    acquireSemaphoreResult: undefined,
    releaseSemaphoreResult: undefined,
    describeSemaphoreResult: undefined,
    describeSemaphoreChanged: undefined,
    createSemaphoreResult: undefined,
    updateSemaphoreResult: undefined,
    deleteSemaphoreResult: undefined,
    unsupported16: undefined,
    unsupported17: undefined,
    unsupported18: undefined,
  };
}

export const SessionResponse = {
  encode(message: SessionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ping !== undefined) {
      SessionResponse_PingPong.encode(message.ping, writer.uint32(10).fork()).ldelim();
    }
    if (message.pong !== undefined) {
      SessionResponse_PingPong.encode(message.pong, writer.uint32(18).fork()).ldelim();
    }
    if (message.failure !== undefined) {
      SessionResponse_Failure.encode(message.failure, writer.uint32(26).fork()).ldelim();
    }
    if (message.sessionStarted !== undefined) {
      SessionResponse_SessionStarted.encode(message.sessionStarted, writer.uint32(34).fork()).ldelim();
    }
    if (message.sessionStopped !== undefined) {
      SessionResponse_SessionStopped.encode(message.sessionStopped, writer.uint32(42).fork()).ldelim();
    }
    if (message.unsupported6 !== undefined) {
      Unsupported.encode(message.unsupported6, writer.uint32(50).fork()).ldelim();
    }
    if (message.unsupported7 !== undefined) {
      Unsupported.encode(message.unsupported7, writer.uint32(58).fork()).ldelim();
    }
    if (message.acquireSemaphorePending !== undefined) {
      SessionResponse_AcquireSemaphorePending.encode(message.acquireSemaphorePending, writer.uint32(66).fork())
        .ldelim();
    }
    if (message.acquireSemaphoreResult !== undefined) {
      SessionResponse_AcquireSemaphoreResult.encode(message.acquireSemaphoreResult, writer.uint32(74).fork()).ldelim();
    }
    if (message.releaseSemaphoreResult !== undefined) {
      SessionResponse_ReleaseSemaphoreResult.encode(message.releaseSemaphoreResult, writer.uint32(82).fork()).ldelim();
    }
    if (message.describeSemaphoreResult !== undefined) {
      SessionResponse_DescribeSemaphoreResult.encode(message.describeSemaphoreResult, writer.uint32(90).fork())
        .ldelim();
    }
    if (message.describeSemaphoreChanged !== undefined) {
      SessionResponse_DescribeSemaphoreChanged.encode(message.describeSemaphoreChanged, writer.uint32(98).fork())
        .ldelim();
    }
    if (message.createSemaphoreResult !== undefined) {
      SessionResponse_CreateSemaphoreResult.encode(message.createSemaphoreResult, writer.uint32(106).fork()).ldelim();
    }
    if (message.updateSemaphoreResult !== undefined) {
      SessionResponse_UpdateSemaphoreResult.encode(message.updateSemaphoreResult, writer.uint32(114).fork()).ldelim();
    }
    if (message.deleteSemaphoreResult !== undefined) {
      SessionResponse_DeleteSemaphoreResult.encode(message.deleteSemaphoreResult, writer.uint32(122).fork()).ldelim();
    }
    if (message.unsupported16 !== undefined) {
      Unsupported.encode(message.unsupported16, writer.uint32(130).fork()).ldelim();
    }
    if (message.unsupported17 !== undefined) {
      Unsupported.encode(message.unsupported17, writer.uint32(138).fork()).ldelim();
    }
    if (message.unsupported18 !== undefined) {
      Unsupported.encode(message.unsupported18, writer.uint32(146).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ping = SessionResponse_PingPong.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pong = SessionResponse_PingPong.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.failure = SessionResponse_Failure.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sessionStarted = SessionResponse_SessionStarted.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sessionStopped = SessionResponse_SessionStopped.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.unsupported6 = Unsupported.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.unsupported7 = Unsupported.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.acquireSemaphorePending = SessionResponse_AcquireSemaphorePending.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.acquireSemaphoreResult = SessionResponse_AcquireSemaphoreResult.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.releaseSemaphoreResult = SessionResponse_ReleaseSemaphoreResult.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.describeSemaphoreResult = SessionResponse_DescribeSemaphoreResult.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.describeSemaphoreChanged = SessionResponse_DescribeSemaphoreChanged.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.createSemaphoreResult = SessionResponse_CreateSemaphoreResult.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.updateSemaphoreResult = SessionResponse_UpdateSemaphoreResult.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.deleteSemaphoreResult = SessionResponse_DeleteSemaphoreResult.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.unsupported16 = Unsupported.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.unsupported17 = Unsupported.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.unsupported18 = Unsupported.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionResponse {
    return {
      ping: isSet(object.ping) ? SessionResponse_PingPong.fromJSON(object.ping) : undefined,
      pong: isSet(object.pong) ? SessionResponse_PingPong.fromJSON(object.pong) : undefined,
      failure: isSet(object.failure) ? SessionResponse_Failure.fromJSON(object.failure) : undefined,
      sessionStarted: isSet(object.sessionStarted)
        ? SessionResponse_SessionStarted.fromJSON(object.sessionStarted)
        : undefined,
      sessionStopped: isSet(object.sessionStopped)
        ? SessionResponse_SessionStopped.fromJSON(object.sessionStopped)
        : undefined,
      unsupported6: isSet(object.unsupported6) ? Unsupported.fromJSON(object.unsupported6) : undefined,
      unsupported7: isSet(object.unsupported7) ? Unsupported.fromJSON(object.unsupported7) : undefined,
      acquireSemaphorePending: isSet(object.acquireSemaphorePending)
        ? SessionResponse_AcquireSemaphorePending.fromJSON(object.acquireSemaphorePending)
        : undefined,
      acquireSemaphoreResult: isSet(object.acquireSemaphoreResult)
        ? SessionResponse_AcquireSemaphoreResult.fromJSON(object.acquireSemaphoreResult)
        : undefined,
      releaseSemaphoreResult: isSet(object.releaseSemaphoreResult)
        ? SessionResponse_ReleaseSemaphoreResult.fromJSON(object.releaseSemaphoreResult)
        : undefined,
      describeSemaphoreResult: isSet(object.describeSemaphoreResult)
        ? SessionResponse_DescribeSemaphoreResult.fromJSON(object.describeSemaphoreResult)
        : undefined,
      describeSemaphoreChanged: isSet(object.describeSemaphoreChanged)
        ? SessionResponse_DescribeSemaphoreChanged.fromJSON(object.describeSemaphoreChanged)
        : undefined,
      createSemaphoreResult: isSet(object.createSemaphoreResult)
        ? SessionResponse_CreateSemaphoreResult.fromJSON(object.createSemaphoreResult)
        : undefined,
      updateSemaphoreResult: isSet(object.updateSemaphoreResult)
        ? SessionResponse_UpdateSemaphoreResult.fromJSON(object.updateSemaphoreResult)
        : undefined,
      deleteSemaphoreResult: isSet(object.deleteSemaphoreResult)
        ? SessionResponse_DeleteSemaphoreResult.fromJSON(object.deleteSemaphoreResult)
        : undefined,
      unsupported16: isSet(object.unsupported16) ? Unsupported.fromJSON(object.unsupported16) : undefined,
      unsupported17: isSet(object.unsupported17) ? Unsupported.fromJSON(object.unsupported17) : undefined,
      unsupported18: isSet(object.unsupported18) ? Unsupported.fromJSON(object.unsupported18) : undefined,
    };
  },

  toJSON(message: SessionResponse): unknown {
    const obj: any = {};
    message.ping !== undefined && (obj.ping = message.ping ? SessionResponse_PingPong.toJSON(message.ping) : undefined);
    message.pong !== undefined && (obj.pong = message.pong ? SessionResponse_PingPong.toJSON(message.pong) : undefined);
    message.failure !== undefined &&
      (obj.failure = message.failure ? SessionResponse_Failure.toJSON(message.failure) : undefined);
    message.sessionStarted !== undefined && (obj.sessionStarted = message.sessionStarted
      ? SessionResponse_SessionStarted.toJSON(message.sessionStarted)
      : undefined);
    message.sessionStopped !== undefined && (obj.sessionStopped = message.sessionStopped
      ? SessionResponse_SessionStopped.toJSON(message.sessionStopped)
      : undefined);
    message.unsupported6 !== undefined &&
      (obj.unsupported6 = message.unsupported6 ? Unsupported.toJSON(message.unsupported6) : undefined);
    message.unsupported7 !== undefined &&
      (obj.unsupported7 = message.unsupported7 ? Unsupported.toJSON(message.unsupported7) : undefined);
    message.acquireSemaphorePending !== undefined && (obj.acquireSemaphorePending = message.acquireSemaphorePending
      ? SessionResponse_AcquireSemaphorePending.toJSON(message.acquireSemaphorePending)
      : undefined);
    message.acquireSemaphoreResult !== undefined && (obj.acquireSemaphoreResult = message.acquireSemaphoreResult
      ? SessionResponse_AcquireSemaphoreResult.toJSON(message.acquireSemaphoreResult)
      : undefined);
    message.releaseSemaphoreResult !== undefined && (obj.releaseSemaphoreResult = message.releaseSemaphoreResult
      ? SessionResponse_ReleaseSemaphoreResult.toJSON(message.releaseSemaphoreResult)
      : undefined);
    message.describeSemaphoreResult !== undefined && (obj.describeSemaphoreResult = message.describeSemaphoreResult
      ? SessionResponse_DescribeSemaphoreResult.toJSON(message.describeSemaphoreResult)
      : undefined);
    message.describeSemaphoreChanged !== undefined && (obj.describeSemaphoreChanged = message.describeSemaphoreChanged
      ? SessionResponse_DescribeSemaphoreChanged.toJSON(message.describeSemaphoreChanged)
      : undefined);
    message.createSemaphoreResult !== undefined && (obj.createSemaphoreResult = message.createSemaphoreResult
      ? SessionResponse_CreateSemaphoreResult.toJSON(message.createSemaphoreResult)
      : undefined);
    message.updateSemaphoreResult !== undefined && (obj.updateSemaphoreResult = message.updateSemaphoreResult
      ? SessionResponse_UpdateSemaphoreResult.toJSON(message.updateSemaphoreResult)
      : undefined);
    message.deleteSemaphoreResult !== undefined && (obj.deleteSemaphoreResult = message.deleteSemaphoreResult
      ? SessionResponse_DeleteSemaphoreResult.toJSON(message.deleteSemaphoreResult)
      : undefined);
    message.unsupported16 !== undefined &&
      (obj.unsupported16 = message.unsupported16 ? Unsupported.toJSON(message.unsupported16) : undefined);
    message.unsupported17 !== undefined &&
      (obj.unsupported17 = message.unsupported17 ? Unsupported.toJSON(message.unsupported17) : undefined);
    message.unsupported18 !== undefined &&
      (obj.unsupported18 = message.unsupported18 ? Unsupported.toJSON(message.unsupported18) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionResponse>, I>>(base?: I): SessionResponse {
    return SessionResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionResponse>, I>>(object: I): SessionResponse {
    const message = createBaseSessionResponse();
    message.ping = (object.ping !== undefined && object.ping !== null)
      ? SessionResponse_PingPong.fromPartial(object.ping)
      : undefined;
    message.pong = (object.pong !== undefined && object.pong !== null)
      ? SessionResponse_PingPong.fromPartial(object.pong)
      : undefined;
    message.failure = (object.failure !== undefined && object.failure !== null)
      ? SessionResponse_Failure.fromPartial(object.failure)
      : undefined;
    message.sessionStarted = (object.sessionStarted !== undefined && object.sessionStarted !== null)
      ? SessionResponse_SessionStarted.fromPartial(object.sessionStarted)
      : undefined;
    message.sessionStopped = (object.sessionStopped !== undefined && object.sessionStopped !== null)
      ? SessionResponse_SessionStopped.fromPartial(object.sessionStopped)
      : undefined;
    message.unsupported6 = (object.unsupported6 !== undefined && object.unsupported6 !== null)
      ? Unsupported.fromPartial(object.unsupported6)
      : undefined;
    message.unsupported7 = (object.unsupported7 !== undefined && object.unsupported7 !== null)
      ? Unsupported.fromPartial(object.unsupported7)
      : undefined;
    message.acquireSemaphorePending =
      (object.acquireSemaphorePending !== undefined && object.acquireSemaphorePending !== null)
        ? SessionResponse_AcquireSemaphorePending.fromPartial(object.acquireSemaphorePending)
        : undefined;
    message.acquireSemaphoreResult =
      (object.acquireSemaphoreResult !== undefined && object.acquireSemaphoreResult !== null)
        ? SessionResponse_AcquireSemaphoreResult.fromPartial(object.acquireSemaphoreResult)
        : undefined;
    message.releaseSemaphoreResult =
      (object.releaseSemaphoreResult !== undefined && object.releaseSemaphoreResult !== null)
        ? SessionResponse_ReleaseSemaphoreResult.fromPartial(object.releaseSemaphoreResult)
        : undefined;
    message.describeSemaphoreResult =
      (object.describeSemaphoreResult !== undefined && object.describeSemaphoreResult !== null)
        ? SessionResponse_DescribeSemaphoreResult.fromPartial(object.describeSemaphoreResult)
        : undefined;
    message.describeSemaphoreChanged =
      (object.describeSemaphoreChanged !== undefined && object.describeSemaphoreChanged !== null)
        ? SessionResponse_DescribeSemaphoreChanged.fromPartial(object.describeSemaphoreChanged)
        : undefined;
    message.createSemaphoreResult =
      (object.createSemaphoreResult !== undefined && object.createSemaphoreResult !== null)
        ? SessionResponse_CreateSemaphoreResult.fromPartial(object.createSemaphoreResult)
        : undefined;
    message.updateSemaphoreResult =
      (object.updateSemaphoreResult !== undefined && object.updateSemaphoreResult !== null)
        ? SessionResponse_UpdateSemaphoreResult.fromPartial(object.updateSemaphoreResult)
        : undefined;
    message.deleteSemaphoreResult =
      (object.deleteSemaphoreResult !== undefined && object.deleteSemaphoreResult !== null)
        ? SessionResponse_DeleteSemaphoreResult.fromPartial(object.deleteSemaphoreResult)
        : undefined;
    message.unsupported16 = (object.unsupported16 !== undefined && object.unsupported16 !== null)
      ? Unsupported.fromPartial(object.unsupported16)
      : undefined;
    message.unsupported17 = (object.unsupported17 !== undefined && object.unsupported17 !== null)
      ? Unsupported.fromPartial(object.unsupported17)
      : undefined;
    message.unsupported18 = (object.unsupported18 !== undefined && object.unsupported18 !== null)
      ? Unsupported.fromPartial(object.unsupported18)
      : undefined;
    return message;
  },
};

function createBaseSessionResponse_PingPong(): SessionResponse_PingPong {
  return { opaque: 0 };
}

export const SessionResponse_PingPong = {
  encode(message: SessionResponse_PingPong, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.opaque !== 0) {
      writer.uint32(8).uint64(message.opaque);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionResponse_PingPong {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionResponse_PingPong();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.opaque = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionResponse_PingPong {
    return { opaque: isSet(object.opaque) ? Number(object.opaque) : 0 };
  },

  toJSON(message: SessionResponse_PingPong): unknown {
    const obj: any = {};
    message.opaque !== undefined && (obj.opaque = Math.round(message.opaque));
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionResponse_PingPong>, I>>(base?: I): SessionResponse_PingPong {
    return SessionResponse_PingPong.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionResponse_PingPong>, I>>(object: I): SessionResponse_PingPong {
    const message = createBaseSessionResponse_PingPong();
    message.opaque = object.opaque ?? 0;
    return message;
  },
};

function createBaseSessionResponse_Failure(): SessionResponse_Failure {
  return { status: 0, issues: [] };
}

export const SessionResponse_Failure = {
  encode(message: SessionResponse_Failure, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    for (const v of message.issues) {
      IssueMessage.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionResponse_Failure {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionResponse_Failure();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.issues.push(IssueMessage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionResponse_Failure {
    return {
      status: isSet(object.status) ? statusIds_StatusCodeFromJSON(object.status) : 0,
      issues: Array.isArray(object?.issues) ? object.issues.map((e: any) => IssueMessage.fromJSON(e)) : [],
    };
  },

  toJSON(message: SessionResponse_Failure): unknown {
    const obj: any = {};
    message.status !== undefined && (obj.status = statusIds_StatusCodeToJSON(message.status));
    if (message.issues) {
      obj.issues = message.issues.map((e) => e ? IssueMessage.toJSON(e) : undefined);
    } else {
      obj.issues = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionResponse_Failure>, I>>(base?: I): SessionResponse_Failure {
    return SessionResponse_Failure.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionResponse_Failure>, I>>(object: I): SessionResponse_Failure {
    const message = createBaseSessionResponse_Failure();
    message.status = object.status ?? 0;
    message.issues = object.issues?.map((e) => IssueMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSessionResponse_SessionStarted(): SessionResponse_SessionStarted {
  return { sessionId: 0, timeoutMillis: 0 };
}

export const SessionResponse_SessionStarted = {
  encode(message: SessionResponse_SessionStarted, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).uint64(message.sessionId);
    }
    if (message.timeoutMillis !== 0) {
      writer.uint32(16).uint64(message.timeoutMillis);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionResponse_SessionStarted {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionResponse_SessionStarted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.timeoutMillis = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionResponse_SessionStarted {
    return {
      sessionId: isSet(object.sessionId) ? Number(object.sessionId) : 0,
      timeoutMillis: isSet(object.timeoutMillis) ? Number(object.timeoutMillis) : 0,
    };
  },

  toJSON(message: SessionResponse_SessionStarted): unknown {
    const obj: any = {};
    message.sessionId !== undefined && (obj.sessionId = Math.round(message.sessionId));
    message.timeoutMillis !== undefined && (obj.timeoutMillis = Math.round(message.timeoutMillis));
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionResponse_SessionStarted>, I>>(base?: I): SessionResponse_SessionStarted {
    return SessionResponse_SessionStarted.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionResponse_SessionStarted>, I>>(
    object: I,
  ): SessionResponse_SessionStarted {
    const message = createBaseSessionResponse_SessionStarted();
    message.sessionId = object.sessionId ?? 0;
    message.timeoutMillis = object.timeoutMillis ?? 0;
    return message;
  },
};

function createBaseSessionResponse_SessionStopped(): SessionResponse_SessionStopped {
  return { sessionId: 0 };
}

export const SessionResponse_SessionStopped = {
  encode(message: SessionResponse_SessionStopped, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sessionId !== 0) {
      writer.uint32(8).uint64(message.sessionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionResponse_SessionStopped {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionResponse_SessionStopped();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sessionId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionResponse_SessionStopped {
    return { sessionId: isSet(object.sessionId) ? Number(object.sessionId) : 0 };
  },

  toJSON(message: SessionResponse_SessionStopped): unknown {
    const obj: any = {};
    message.sessionId !== undefined && (obj.sessionId = Math.round(message.sessionId));
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionResponse_SessionStopped>, I>>(base?: I): SessionResponse_SessionStopped {
    return SessionResponse_SessionStopped.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionResponse_SessionStopped>, I>>(
    object: I,
  ): SessionResponse_SessionStopped {
    const message = createBaseSessionResponse_SessionStopped();
    message.sessionId = object.sessionId ?? 0;
    return message;
  },
};

function createBaseSessionResponse_AcquireSemaphorePending(): SessionResponse_AcquireSemaphorePending {
  return { reqId: 0 };
}

export const SessionResponse_AcquireSemaphorePending = {
  encode(message: SessionResponse_AcquireSemaphorePending, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reqId !== 0) {
      writer.uint32(8).uint64(message.reqId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionResponse_AcquireSemaphorePending {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionResponse_AcquireSemaphorePending();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reqId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionResponse_AcquireSemaphorePending {
    return { reqId: isSet(object.reqId) ? Number(object.reqId) : 0 };
  },

  toJSON(message: SessionResponse_AcquireSemaphorePending): unknown {
    const obj: any = {};
    message.reqId !== undefined && (obj.reqId = Math.round(message.reqId));
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionResponse_AcquireSemaphorePending>, I>>(
    base?: I,
  ): SessionResponse_AcquireSemaphorePending {
    return SessionResponse_AcquireSemaphorePending.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionResponse_AcquireSemaphorePending>, I>>(
    object: I,
  ): SessionResponse_AcquireSemaphorePending {
    const message = createBaseSessionResponse_AcquireSemaphorePending();
    message.reqId = object.reqId ?? 0;
    return message;
  },
};

function createBaseSessionResponse_AcquireSemaphoreResult(): SessionResponse_AcquireSemaphoreResult {
  return { reqId: 0, status: 0, issues: [], acquired: false };
}

export const SessionResponse_AcquireSemaphoreResult = {
  encode(message: SessionResponse_AcquireSemaphoreResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reqId !== 0) {
      writer.uint32(8).uint64(message.reqId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    for (const v of message.issues) {
      IssueMessage.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.acquired === true) {
      writer.uint32(32).bool(message.acquired);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionResponse_AcquireSemaphoreResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionResponse_AcquireSemaphoreResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reqId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.issues.push(IssueMessage.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.acquired = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionResponse_AcquireSemaphoreResult {
    return {
      reqId: isSet(object.reqId) ? Number(object.reqId) : 0,
      status: isSet(object.status) ? statusIds_StatusCodeFromJSON(object.status) : 0,
      issues: Array.isArray(object?.issues) ? object.issues.map((e: any) => IssueMessage.fromJSON(e)) : [],
      acquired: isSet(object.acquired) ? Boolean(object.acquired) : false,
    };
  },

  toJSON(message: SessionResponse_AcquireSemaphoreResult): unknown {
    const obj: any = {};
    message.reqId !== undefined && (obj.reqId = Math.round(message.reqId));
    message.status !== undefined && (obj.status = statusIds_StatusCodeToJSON(message.status));
    if (message.issues) {
      obj.issues = message.issues.map((e) => e ? IssueMessage.toJSON(e) : undefined);
    } else {
      obj.issues = [];
    }
    message.acquired !== undefined && (obj.acquired = message.acquired);
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionResponse_AcquireSemaphoreResult>, I>>(
    base?: I,
  ): SessionResponse_AcquireSemaphoreResult {
    return SessionResponse_AcquireSemaphoreResult.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionResponse_AcquireSemaphoreResult>, I>>(
    object: I,
  ): SessionResponse_AcquireSemaphoreResult {
    const message = createBaseSessionResponse_AcquireSemaphoreResult();
    message.reqId = object.reqId ?? 0;
    message.status = object.status ?? 0;
    message.issues = object.issues?.map((e) => IssueMessage.fromPartial(e)) || [];
    message.acquired = object.acquired ?? false;
    return message;
  },
};

function createBaseSessionResponse_ReleaseSemaphoreResult(): SessionResponse_ReleaseSemaphoreResult {
  return { reqId: 0, status: 0, issues: [], released: false };
}

export const SessionResponse_ReleaseSemaphoreResult = {
  encode(message: SessionResponse_ReleaseSemaphoreResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reqId !== 0) {
      writer.uint32(8).uint64(message.reqId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    for (const v of message.issues) {
      IssueMessage.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.released === true) {
      writer.uint32(32).bool(message.released);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionResponse_ReleaseSemaphoreResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionResponse_ReleaseSemaphoreResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reqId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.issues.push(IssueMessage.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.released = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionResponse_ReleaseSemaphoreResult {
    return {
      reqId: isSet(object.reqId) ? Number(object.reqId) : 0,
      status: isSet(object.status) ? statusIds_StatusCodeFromJSON(object.status) : 0,
      issues: Array.isArray(object?.issues) ? object.issues.map((e: any) => IssueMessage.fromJSON(e)) : [],
      released: isSet(object.released) ? Boolean(object.released) : false,
    };
  },

  toJSON(message: SessionResponse_ReleaseSemaphoreResult): unknown {
    const obj: any = {};
    message.reqId !== undefined && (obj.reqId = Math.round(message.reqId));
    message.status !== undefined && (obj.status = statusIds_StatusCodeToJSON(message.status));
    if (message.issues) {
      obj.issues = message.issues.map((e) => e ? IssueMessage.toJSON(e) : undefined);
    } else {
      obj.issues = [];
    }
    message.released !== undefined && (obj.released = message.released);
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionResponse_ReleaseSemaphoreResult>, I>>(
    base?: I,
  ): SessionResponse_ReleaseSemaphoreResult {
    return SessionResponse_ReleaseSemaphoreResult.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionResponse_ReleaseSemaphoreResult>, I>>(
    object: I,
  ): SessionResponse_ReleaseSemaphoreResult {
    const message = createBaseSessionResponse_ReleaseSemaphoreResult();
    message.reqId = object.reqId ?? 0;
    message.status = object.status ?? 0;
    message.issues = object.issues?.map((e) => IssueMessage.fromPartial(e)) || [];
    message.released = object.released ?? false;
    return message;
  },
};

function createBaseSessionResponse_DescribeSemaphoreResult(): SessionResponse_DescribeSemaphoreResult {
  return { reqId: 0, status: 0, issues: [], semaphoreDescription: undefined, watchAdded: false };
}

export const SessionResponse_DescribeSemaphoreResult = {
  encode(message: SessionResponse_DescribeSemaphoreResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reqId !== 0) {
      writer.uint32(8).uint64(message.reqId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    for (const v of message.issues) {
      IssueMessage.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.semaphoreDescription !== undefined) {
      SemaphoreDescription.encode(message.semaphoreDescription, writer.uint32(34).fork()).ldelim();
    }
    if (message.watchAdded === true) {
      writer.uint32(40).bool(message.watchAdded);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionResponse_DescribeSemaphoreResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionResponse_DescribeSemaphoreResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reqId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.issues.push(IssueMessage.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.semaphoreDescription = SemaphoreDescription.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.watchAdded = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionResponse_DescribeSemaphoreResult {
    return {
      reqId: isSet(object.reqId) ? Number(object.reqId) : 0,
      status: isSet(object.status) ? statusIds_StatusCodeFromJSON(object.status) : 0,
      issues: Array.isArray(object?.issues) ? object.issues.map((e: any) => IssueMessage.fromJSON(e)) : [],
      semaphoreDescription: isSet(object.semaphoreDescription)
        ? SemaphoreDescription.fromJSON(object.semaphoreDescription)
        : undefined,
      watchAdded: isSet(object.watchAdded) ? Boolean(object.watchAdded) : false,
    };
  },

  toJSON(message: SessionResponse_DescribeSemaphoreResult): unknown {
    const obj: any = {};
    message.reqId !== undefined && (obj.reqId = Math.round(message.reqId));
    message.status !== undefined && (obj.status = statusIds_StatusCodeToJSON(message.status));
    if (message.issues) {
      obj.issues = message.issues.map((e) => e ? IssueMessage.toJSON(e) : undefined);
    } else {
      obj.issues = [];
    }
    message.semaphoreDescription !== undefined && (obj.semaphoreDescription = message.semaphoreDescription
      ? SemaphoreDescription.toJSON(message.semaphoreDescription)
      : undefined);
    message.watchAdded !== undefined && (obj.watchAdded = message.watchAdded);
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionResponse_DescribeSemaphoreResult>, I>>(
    base?: I,
  ): SessionResponse_DescribeSemaphoreResult {
    return SessionResponse_DescribeSemaphoreResult.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionResponse_DescribeSemaphoreResult>, I>>(
    object: I,
  ): SessionResponse_DescribeSemaphoreResult {
    const message = createBaseSessionResponse_DescribeSemaphoreResult();
    message.reqId = object.reqId ?? 0;
    message.status = object.status ?? 0;
    message.issues = object.issues?.map((e) => IssueMessage.fromPartial(e)) || [];
    message.semaphoreDescription = (object.semaphoreDescription !== undefined && object.semaphoreDescription !== null)
      ? SemaphoreDescription.fromPartial(object.semaphoreDescription)
      : undefined;
    message.watchAdded = object.watchAdded ?? false;
    return message;
  },
};

function createBaseSessionResponse_DescribeSemaphoreChanged(): SessionResponse_DescribeSemaphoreChanged {
  return { reqId: 0, dataChanged: false, ownersChanged: false };
}

export const SessionResponse_DescribeSemaphoreChanged = {
  encode(message: SessionResponse_DescribeSemaphoreChanged, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reqId !== 0) {
      writer.uint32(8).uint64(message.reqId);
    }
    if (message.dataChanged === true) {
      writer.uint32(16).bool(message.dataChanged);
    }
    if (message.ownersChanged === true) {
      writer.uint32(24).bool(message.ownersChanged);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionResponse_DescribeSemaphoreChanged {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionResponse_DescribeSemaphoreChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reqId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.dataChanged = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ownersChanged = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionResponse_DescribeSemaphoreChanged {
    return {
      reqId: isSet(object.reqId) ? Number(object.reqId) : 0,
      dataChanged: isSet(object.dataChanged) ? Boolean(object.dataChanged) : false,
      ownersChanged: isSet(object.ownersChanged) ? Boolean(object.ownersChanged) : false,
    };
  },

  toJSON(message: SessionResponse_DescribeSemaphoreChanged): unknown {
    const obj: any = {};
    message.reqId !== undefined && (obj.reqId = Math.round(message.reqId));
    message.dataChanged !== undefined && (obj.dataChanged = message.dataChanged);
    message.ownersChanged !== undefined && (obj.ownersChanged = message.ownersChanged);
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionResponse_DescribeSemaphoreChanged>, I>>(
    base?: I,
  ): SessionResponse_DescribeSemaphoreChanged {
    return SessionResponse_DescribeSemaphoreChanged.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionResponse_DescribeSemaphoreChanged>, I>>(
    object: I,
  ): SessionResponse_DescribeSemaphoreChanged {
    const message = createBaseSessionResponse_DescribeSemaphoreChanged();
    message.reqId = object.reqId ?? 0;
    message.dataChanged = object.dataChanged ?? false;
    message.ownersChanged = object.ownersChanged ?? false;
    return message;
  },
};

function createBaseSessionResponse_CreateSemaphoreResult(): SessionResponse_CreateSemaphoreResult {
  return { reqId: 0, status: 0, issues: [] };
}

export const SessionResponse_CreateSemaphoreResult = {
  encode(message: SessionResponse_CreateSemaphoreResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reqId !== 0) {
      writer.uint32(8).uint64(message.reqId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    for (const v of message.issues) {
      IssueMessage.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionResponse_CreateSemaphoreResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionResponse_CreateSemaphoreResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reqId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.issues.push(IssueMessage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionResponse_CreateSemaphoreResult {
    return {
      reqId: isSet(object.reqId) ? Number(object.reqId) : 0,
      status: isSet(object.status) ? statusIds_StatusCodeFromJSON(object.status) : 0,
      issues: Array.isArray(object?.issues) ? object.issues.map((e: any) => IssueMessage.fromJSON(e)) : [],
    };
  },

  toJSON(message: SessionResponse_CreateSemaphoreResult): unknown {
    const obj: any = {};
    message.reqId !== undefined && (obj.reqId = Math.round(message.reqId));
    message.status !== undefined && (obj.status = statusIds_StatusCodeToJSON(message.status));
    if (message.issues) {
      obj.issues = message.issues.map((e) => e ? IssueMessage.toJSON(e) : undefined);
    } else {
      obj.issues = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionResponse_CreateSemaphoreResult>, I>>(
    base?: I,
  ): SessionResponse_CreateSemaphoreResult {
    return SessionResponse_CreateSemaphoreResult.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionResponse_CreateSemaphoreResult>, I>>(
    object: I,
  ): SessionResponse_CreateSemaphoreResult {
    const message = createBaseSessionResponse_CreateSemaphoreResult();
    message.reqId = object.reqId ?? 0;
    message.status = object.status ?? 0;
    message.issues = object.issues?.map((e) => IssueMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSessionResponse_UpdateSemaphoreResult(): SessionResponse_UpdateSemaphoreResult {
  return { reqId: 0, status: 0, issues: [] };
}

export const SessionResponse_UpdateSemaphoreResult = {
  encode(message: SessionResponse_UpdateSemaphoreResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reqId !== 0) {
      writer.uint32(8).uint64(message.reqId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    for (const v of message.issues) {
      IssueMessage.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionResponse_UpdateSemaphoreResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionResponse_UpdateSemaphoreResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reqId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.issues.push(IssueMessage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionResponse_UpdateSemaphoreResult {
    return {
      reqId: isSet(object.reqId) ? Number(object.reqId) : 0,
      status: isSet(object.status) ? statusIds_StatusCodeFromJSON(object.status) : 0,
      issues: Array.isArray(object?.issues) ? object.issues.map((e: any) => IssueMessage.fromJSON(e)) : [],
    };
  },

  toJSON(message: SessionResponse_UpdateSemaphoreResult): unknown {
    const obj: any = {};
    message.reqId !== undefined && (obj.reqId = Math.round(message.reqId));
    message.status !== undefined && (obj.status = statusIds_StatusCodeToJSON(message.status));
    if (message.issues) {
      obj.issues = message.issues.map((e) => e ? IssueMessage.toJSON(e) : undefined);
    } else {
      obj.issues = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionResponse_UpdateSemaphoreResult>, I>>(
    base?: I,
  ): SessionResponse_UpdateSemaphoreResult {
    return SessionResponse_UpdateSemaphoreResult.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionResponse_UpdateSemaphoreResult>, I>>(
    object: I,
  ): SessionResponse_UpdateSemaphoreResult {
    const message = createBaseSessionResponse_UpdateSemaphoreResult();
    message.reqId = object.reqId ?? 0;
    message.status = object.status ?? 0;
    message.issues = object.issues?.map((e) => IssueMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSessionResponse_DeleteSemaphoreResult(): SessionResponse_DeleteSemaphoreResult {
  return { reqId: 0, status: 0, issues: [] };
}

export const SessionResponse_DeleteSemaphoreResult = {
  encode(message: SessionResponse_DeleteSemaphoreResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.reqId !== 0) {
      writer.uint32(8).uint64(message.reqId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    for (const v of message.issues) {
      IssueMessage.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SessionResponse_DeleteSemaphoreResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionResponse_DeleteSemaphoreResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reqId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.issues.push(IssueMessage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionResponse_DeleteSemaphoreResult {
    return {
      reqId: isSet(object.reqId) ? Number(object.reqId) : 0,
      status: isSet(object.status) ? statusIds_StatusCodeFromJSON(object.status) : 0,
      issues: Array.isArray(object?.issues) ? object.issues.map((e: any) => IssueMessage.fromJSON(e)) : [],
    };
  },

  toJSON(message: SessionResponse_DeleteSemaphoreResult): unknown {
    const obj: any = {};
    message.reqId !== undefined && (obj.reqId = Math.round(message.reqId));
    message.status !== undefined && (obj.status = statusIds_StatusCodeToJSON(message.status));
    if (message.issues) {
      obj.issues = message.issues.map((e) => e ? IssueMessage.toJSON(e) : undefined);
    } else {
      obj.issues = [];
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SessionResponse_DeleteSemaphoreResult>, I>>(
    base?: I,
  ): SessionResponse_DeleteSemaphoreResult {
    return SessionResponse_DeleteSemaphoreResult.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<SessionResponse_DeleteSemaphoreResult>, I>>(
    object: I,
  ): SessionResponse_DeleteSemaphoreResult {
    const message = createBaseSessionResponse_DeleteSemaphoreResult();
    message.reqId = object.reqId ?? 0;
    message.status = object.status ?? 0;
    message.issues = object.issues?.map((e) => IssueMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateNodeRequest(): CreateNodeRequest {
  return { path: "", config: undefined, operationParams: undefined };
}

export const CreateNodeRequest = {
  encode(message: CreateNodeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.config !== undefined) {
      Config.encode(message.config, writer.uint32(18).fork()).ldelim();
    }
    if (message.operationParams !== undefined) {
      OperationParams.encode(message.operationParams, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateNodeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.config = Config.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.operationParams = OperationParams.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNodeRequest {
    return {
      path: isSet(object.path) ? String(object.path) : "",
      config: isSet(object.config) ? Config.fromJSON(object.config) : undefined,
      operationParams: isSet(object.operationParams) ? OperationParams.fromJSON(object.operationParams) : undefined,
    };
  },

  toJSON(message: CreateNodeRequest): unknown {
    const obj: any = {};
    message.path !== undefined && (obj.path = message.path);
    message.config !== undefined && (obj.config = message.config ? Config.toJSON(message.config) : undefined);
    message.operationParams !== undefined &&
      (obj.operationParams = message.operationParams ? OperationParams.toJSON(message.operationParams) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateNodeRequest>, I>>(base?: I): CreateNodeRequest {
    return CreateNodeRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CreateNodeRequest>, I>>(object: I): CreateNodeRequest {
    const message = createBaseCreateNodeRequest();
    message.path = object.path ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? Config.fromPartial(object.config)
      : undefined;
    message.operationParams = (object.operationParams !== undefined && object.operationParams !== null)
      ? OperationParams.fromPartial(object.operationParams)
      : undefined;
    return message;
  },
};

function createBaseCreateNodeResponse(): CreateNodeResponse {
  return { operation: undefined };
}

export const CreateNodeResponse = {
  encode(message: CreateNodeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operation !== undefined) {
      Operation.encode(message.operation, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateNodeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operation = Operation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNodeResponse {
    return { operation: isSet(object.operation) ? Operation.fromJSON(object.operation) : undefined };
  },

  toJSON(message: CreateNodeResponse): unknown {
    const obj: any = {};
    message.operation !== undefined &&
      (obj.operation = message.operation ? Operation.toJSON(message.operation) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateNodeResponse>, I>>(base?: I): CreateNodeResponse {
    return CreateNodeResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<CreateNodeResponse>, I>>(object: I): CreateNodeResponse {
    const message = createBaseCreateNodeResponse();
    message.operation = (object.operation !== undefined && object.operation !== null)
      ? Operation.fromPartial(object.operation)
      : undefined;
    return message;
  },
};

function createBaseAlterNodeRequest(): AlterNodeRequest {
  return { path: "", config: undefined, operationParams: undefined };
}

export const AlterNodeRequest = {
  encode(message: AlterNodeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.config !== undefined) {
      Config.encode(message.config, writer.uint32(18).fork()).ldelim();
    }
    if (message.operationParams !== undefined) {
      OperationParams.encode(message.operationParams, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AlterNodeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlterNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.config = Config.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.operationParams = OperationParams.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlterNodeRequest {
    return {
      path: isSet(object.path) ? String(object.path) : "",
      config: isSet(object.config) ? Config.fromJSON(object.config) : undefined,
      operationParams: isSet(object.operationParams) ? OperationParams.fromJSON(object.operationParams) : undefined,
    };
  },

  toJSON(message: AlterNodeRequest): unknown {
    const obj: any = {};
    message.path !== undefined && (obj.path = message.path);
    message.config !== undefined && (obj.config = message.config ? Config.toJSON(message.config) : undefined);
    message.operationParams !== undefined &&
      (obj.operationParams = message.operationParams ? OperationParams.toJSON(message.operationParams) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<AlterNodeRequest>, I>>(base?: I): AlterNodeRequest {
    return AlterNodeRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AlterNodeRequest>, I>>(object: I): AlterNodeRequest {
    const message = createBaseAlterNodeRequest();
    message.path = object.path ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? Config.fromPartial(object.config)
      : undefined;
    message.operationParams = (object.operationParams !== undefined && object.operationParams !== null)
      ? OperationParams.fromPartial(object.operationParams)
      : undefined;
    return message;
  },
};

function createBaseAlterNodeResponse(): AlterNodeResponse {
  return { operation: undefined };
}

export const AlterNodeResponse = {
  encode(message: AlterNodeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operation !== undefined) {
      Operation.encode(message.operation, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AlterNodeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlterNodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operation = Operation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlterNodeResponse {
    return { operation: isSet(object.operation) ? Operation.fromJSON(object.operation) : undefined };
  },

  toJSON(message: AlterNodeResponse): unknown {
    const obj: any = {};
    message.operation !== undefined &&
      (obj.operation = message.operation ? Operation.toJSON(message.operation) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<AlterNodeResponse>, I>>(base?: I): AlterNodeResponse {
    return AlterNodeResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<AlterNodeResponse>, I>>(object: I): AlterNodeResponse {
    const message = createBaseAlterNodeResponse();
    message.operation = (object.operation !== undefined && object.operation !== null)
      ? Operation.fromPartial(object.operation)
      : undefined;
    return message;
  },
};

function createBaseDropNodeRequest(): DropNodeRequest {
  return { path: "", operationParams: undefined };
}

export const DropNodeRequest = {
  encode(message: DropNodeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.operationParams !== undefined) {
      OperationParams.encode(message.operationParams, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DropNodeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDropNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operationParams = OperationParams.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DropNodeRequest {
    return {
      path: isSet(object.path) ? String(object.path) : "",
      operationParams: isSet(object.operationParams) ? OperationParams.fromJSON(object.operationParams) : undefined,
    };
  },

  toJSON(message: DropNodeRequest): unknown {
    const obj: any = {};
    message.path !== undefined && (obj.path = message.path);
    message.operationParams !== undefined &&
      (obj.operationParams = message.operationParams ? OperationParams.toJSON(message.operationParams) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<DropNodeRequest>, I>>(base?: I): DropNodeRequest {
    return DropNodeRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DropNodeRequest>, I>>(object: I): DropNodeRequest {
    const message = createBaseDropNodeRequest();
    message.path = object.path ?? "";
    message.operationParams = (object.operationParams !== undefined && object.operationParams !== null)
      ? OperationParams.fromPartial(object.operationParams)
      : undefined;
    return message;
  },
};

function createBaseDropNodeResponse(): DropNodeResponse {
  return { operation: undefined };
}

export const DropNodeResponse = {
  encode(message: DropNodeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operation !== undefined) {
      Operation.encode(message.operation, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DropNodeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDropNodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operation = Operation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DropNodeResponse {
    return { operation: isSet(object.operation) ? Operation.fromJSON(object.operation) : undefined };
  },

  toJSON(message: DropNodeResponse): unknown {
    const obj: any = {};
    message.operation !== undefined &&
      (obj.operation = message.operation ? Operation.toJSON(message.operation) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<DropNodeResponse>, I>>(base?: I): DropNodeResponse {
    return DropNodeResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DropNodeResponse>, I>>(object: I): DropNodeResponse {
    const message = createBaseDropNodeResponse();
    message.operation = (object.operation !== undefined && object.operation !== null)
      ? Operation.fromPartial(object.operation)
      : undefined;
    return message;
  },
};

function createBaseDescribeNodeRequest(): DescribeNodeRequest {
  return { path: "", operationParams: undefined };
}

export const DescribeNodeRequest = {
  encode(message: DescribeNodeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.operationParams !== undefined) {
      OperationParams.encode(message.operationParams, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DescribeNodeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDescribeNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operationParams = OperationParams.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DescribeNodeRequest {
    return {
      path: isSet(object.path) ? String(object.path) : "",
      operationParams: isSet(object.operationParams) ? OperationParams.fromJSON(object.operationParams) : undefined,
    };
  },

  toJSON(message: DescribeNodeRequest): unknown {
    const obj: any = {};
    message.path !== undefined && (obj.path = message.path);
    message.operationParams !== undefined &&
      (obj.operationParams = message.operationParams ? OperationParams.toJSON(message.operationParams) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<DescribeNodeRequest>, I>>(base?: I): DescribeNodeRequest {
    return DescribeNodeRequest.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DescribeNodeRequest>, I>>(object: I): DescribeNodeRequest {
    const message = createBaseDescribeNodeRequest();
    message.path = object.path ?? "";
    message.operationParams = (object.operationParams !== undefined && object.operationParams !== null)
      ? OperationParams.fromPartial(object.operationParams)
      : undefined;
    return message;
  },
};

function createBaseDescribeNodeResponse(): DescribeNodeResponse {
  return { operation: undefined };
}

export const DescribeNodeResponse = {
  encode(message: DescribeNodeResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operation !== undefined) {
      Operation.encode(message.operation, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DescribeNodeResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDescribeNodeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operation = Operation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DescribeNodeResponse {
    return { operation: isSet(object.operation) ? Operation.fromJSON(object.operation) : undefined };
  },

  toJSON(message: DescribeNodeResponse): unknown {
    const obj: any = {};
    message.operation !== undefined &&
      (obj.operation = message.operation ? Operation.toJSON(message.operation) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<DescribeNodeResponse>, I>>(base?: I): DescribeNodeResponse {
    return DescribeNodeResponse.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DescribeNodeResponse>, I>>(object: I): DescribeNodeResponse {
    const message = createBaseDescribeNodeResponse();
    message.operation = (object.operation !== undefined && object.operation !== null)
      ? Operation.fromPartial(object.operation)
      : undefined;
    return message;
  },
};

function createBaseDescribeNodeResult(): DescribeNodeResult {
  return { self: undefined, config: undefined };
}

export const DescribeNodeResult = {
  encode(message: DescribeNodeResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.self !== undefined) {
      Entry.encode(message.self, writer.uint32(10).fork()).ldelim();
    }
    if (message.config !== undefined) {
      Config.encode(message.config, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DescribeNodeResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDescribeNodeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.self = Entry.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.config = Config.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DescribeNodeResult {
    return {
      self: isSet(object.self) ? Entry.fromJSON(object.self) : undefined,
      config: isSet(object.config) ? Config.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: DescribeNodeResult): unknown {
    const obj: any = {};
    message.self !== undefined && (obj.self = message.self ? Entry.toJSON(message.self) : undefined);
    message.config !== undefined && (obj.config = message.config ? Config.toJSON(message.config) : undefined);
    return obj;
  },

  create<I extends Exact<DeepPartial<DescribeNodeResult>, I>>(base?: I): DescribeNodeResult {
    return DescribeNodeResult.fromPartial(base ?? {});
  },

  fromPartial<I extends Exact<DeepPartial<DescribeNodeResult>, I>>(object: I): DescribeNodeResult {
    const message = createBaseDescribeNodeResult();
    message.self = (object.self !== undefined && object.self !== null) ? Entry.fromPartial(object.self) : undefined;
    message.config = (object.config !== undefined && object.config !== null)
      ? Config.fromPartial(object.config)
      : undefined;
    return message;
  },
};

declare var self: any | undefined;
declare var window: any | undefined;
declare var global: any | undefined;
var tsProtoGlobalThis: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

function bytesFromBase64(b64: string): Uint8Array {
  if (tsProtoGlobalThis.Buffer) {
    return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = tsProtoGlobalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if (tsProtoGlobalThis.Buffer) {
    return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(String.fromCharCode(byte));
    });
    return tsProtoGlobalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new tsProtoGlobalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

// If you get a compile-error about 'Constructor<Long> and ... have no overlap',
// add '--ts_proto_opt=esModuleInterop=true' as a flag when calling 'protoc'.
if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
