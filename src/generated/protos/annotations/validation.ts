/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 0.0.0
 * source: protos/annotations/validation.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./../../google/protobuf/descriptor";
import * as pb_1 from "google-protobuf";
export namespace Ydb {
    export class Limit extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3, 4, 5, 6]];
        constructor(data?: any[] | ({} & (({
            range?: Limit.Range;
            lt?: never;
            le?: never;
            eq?: never;
            ge?: never;
            gt?: never;
        } | {
            range?: never;
            lt?: number;
            le?: never;
            eq?: never;
            ge?: never;
            gt?: never;
        } | {
            range?: never;
            lt?: never;
            le?: number;
            eq?: never;
            ge?: never;
            gt?: never;
        } | {
            range?: never;
            lt?: never;
            le?: never;
            eq?: number;
            ge?: never;
            gt?: never;
        } | {
            range?: never;
            lt?: never;
            le?: never;
            eq?: never;
            ge?: number;
            gt?: never;
        } | {
            range?: never;
            lt?: never;
            le?: never;
            eq?: never;
            ge?: never;
            gt?: number;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("range" in data && data.range != undefined) {
                    this.range = data.range;
                }
                if ("lt" in data && data.lt != undefined) {
                    this.lt = data.lt;
                }
                if ("le" in data && data.le != undefined) {
                    this.le = data.le;
                }
                if ("eq" in data && data.eq != undefined) {
                    this.eq = data.eq;
                }
                if ("ge" in data && data.ge != undefined) {
                    this.ge = data.ge;
                }
                if ("gt" in data && data.gt != undefined) {
                    this.gt = data.gt;
                }
            }
        }
        get range() {
            return pb_1.Message.getWrapperField(this, Limit.Range, 1) as Limit.Range;
        }
        set range(value: Limit.Range) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_range() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get lt() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set lt(value: number) {
            pb_1.Message.setOneofField(this, 2, this.#one_of_decls[0], value);
        }
        get has_lt() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get le() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set le(value: number) {
            pb_1.Message.setOneofField(this, 3, this.#one_of_decls[0], value);
        }
        get has_le() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get eq() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set eq(value: number) {
            pb_1.Message.setOneofField(this, 4, this.#one_of_decls[0], value);
        }
        get has_eq() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get ge() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set ge(value: number) {
            pb_1.Message.setOneofField(this, 5, this.#one_of_decls[0], value);
        }
        get has_ge() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get gt() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set gt(value: number) {
            pb_1.Message.setOneofField(this, 6, this.#one_of_decls[0], value);
        }
        get has_gt() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get kind() {
            const cases: {
                [index: number]: "none" | "range" | "lt" | "le" | "eq" | "ge" | "gt";
            } = {
                0: "none",
                1: "range",
                2: "lt",
                3: "le",
                4: "eq",
                5: "ge",
                6: "gt"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5, 6])];
        }
        static fromObject(data: {
            range?: ReturnType<typeof Limit.Range.prototype.toObject>;
            lt?: number;
            le?: number;
            eq?: number;
            ge?: number;
            gt?: number;
        }): Limit {
            const message = new Limit({});
            if (data.range != null) {
                message.range = Limit.Range.fromObject(data.range);
            }
            if (data.lt != null) {
                message.lt = data.lt;
            }
            if (data.le != null) {
                message.le = data.le;
            }
            if (data.eq != null) {
                message.eq = data.eq;
            }
            if (data.ge != null) {
                message.ge = data.ge;
            }
            if (data.gt != null) {
                message.gt = data.gt;
            }
            return message;
        }
        toObject() {
            const data: {
                range?: ReturnType<typeof Limit.Range.prototype.toObject>;
                lt?: number;
                le?: number;
                eq?: number;
                ge?: number;
                gt?: number;
            } = {};
            if (this.range != null) {
                data.range = this.range.toObject();
            }
            if (this.lt != null) {
                data.lt = this.lt;
            }
            if (this.le != null) {
                data.le = this.le;
            }
            if (this.eq != null) {
                data.eq = this.eq;
            }
            if (this.ge != null) {
                data.ge = this.ge;
            }
            if (this.gt != null) {
                data.gt = this.gt;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_range)
                writer.writeMessage(1, this.range, () => this.range.serialize(writer));
            if (this.has_lt)
                writer.writeUint32(2, this.lt);
            if (this.has_le)
                writer.writeUint32(3, this.le);
            if (this.has_eq)
                writer.writeUint32(4, this.eq);
            if (this.has_ge)
                writer.writeUint32(5, this.ge);
            if (this.has_gt)
                writer.writeUint32(6, this.gt);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Limit {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Limit();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.range, () => message.range = Limit.Range.deserialize(reader));
                        break;
                    case 2:
                        message.lt = reader.readUint32();
                        break;
                    case 3:
                        message.le = reader.readUint32();
                        break;
                    case 4:
                        message.eq = reader.readUint32();
                        break;
                    case 5:
                        message.ge = reader.readUint32();
                        break;
                    case 6:
                        message.gt = reader.readUint32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Limit {
            return Limit.deserialize(bytes);
        }
    }
    export namespace Limit {
        export class Range extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                min?: number;
                max?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("min" in data && data.min != undefined) {
                        this.min = data.min;
                    }
                    if ("max" in data && data.max != undefined) {
                        this.max = data.max;
                    }
                }
            }
            get min() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set min(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get max() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set max(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            static fromObject(data: {
                min?: number;
                max?: number;
            }): Range {
                const message = new Range({});
                if (data.min != null) {
                    message.min = data.min;
                }
                if (data.max != null) {
                    message.max = data.max;
                }
                return message;
            }
            toObject() {
                const data: {
                    min?: number;
                    max?: number;
                } = {};
                if (this.min != null) {
                    data.min = this.min;
                }
                if (this.max != null) {
                    data.max = this.max;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.min != 0)
                    writer.writeUint32(1, this.min);
                if (this.max != 0)
                    writer.writeUint32(2, this.max);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Range {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Range();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.min = reader.readUint32();
                            break;
                        case 2:
                            message.max = reader.readUint32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Range {
                return Range.deserialize(bytes);
            }
        }
    }
    export class MapKey extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            length?: Limit;
            value?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("length" in data && data.length != undefined) {
                    this.length = data.length;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get length() {
            return pb_1.Message.getWrapperField(this, Limit, 1) as Limit;
        }
        set length(value: Limit) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_length() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set value(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            length?: ReturnType<typeof Limit.prototype.toObject>;
            value?: string;
        }): MapKey {
            const message = new MapKey({});
            if (data.length != null) {
                message.length = Limit.fromObject(data.length);
            }
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                length?: ReturnType<typeof Limit.prototype.toObject>;
                value?: string;
            } = {};
            if (this.length != null) {
                data.length = this.length.toObject();
            }
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_length)
                writer.writeMessage(1, this.length, () => this.length.serialize(writer));
            if (this.value.length)
                writer.writeString(2, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MapKey {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MapKey();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.length, () => message.length = Limit.deserialize(reader));
                        break;
                    case 2:
                        message.value = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MapKey {
            return MapKey.deserialize(bytes);
        }
    }
}
